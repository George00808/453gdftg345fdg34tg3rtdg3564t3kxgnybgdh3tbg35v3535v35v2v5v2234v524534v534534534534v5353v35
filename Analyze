GTPlayer:

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using AA;
using BoingKit;
using GorillaExtensions;
using GorillaLocomotion.Climbing;
using GorillaLocomotion.Gameplay;
using GorillaLocomotion.Swimming;
using GorillaTag;
using GorillaTagScripts;
using Photon.Pun;
using UnityEngine;
using UnityEngine.XR;

namespace GorillaLocomotion
{
	// Token: 0x02000F5C RID: 3932
	public class GTPlayer : MonoBehaviour
	{
		// Token: 0x1700094E RID: 2382
		// (get) Token: 0x06006295 RID: 25237 RVA: 0x0007C9DC File Offset: 0x0007ABDC
		public static GTPlayer Instance
		{
			get
			{
				return GTPlayer._instance;
			}
		}

		// Token: 0x1700094F RID: 2383
		// (get) Token: 0x06006296 RID: 25238 RVA: 0x0007C9E3 File Offset: 0x0007ABE3
		public GTPlayer.HandState LeftHand
		{
			get
			{
				return this.leftHand;
			}
		}

		// Token: 0x17000950 RID: 2384
		// (get) Token: 0x06006297 RID: 25239 RVA: 0x0007C9EB File Offset: 0x0007ABEB
		public GTPlayer.HandState RightHand
		{
			get
			{
				return this.rightHand;
			}
		}

		// Token: 0x06006298 RID: 25240 RVA: 0x0007C9F3 File Offset: 0x0007ABF3
		public int GetMaterialTouchIndex(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).materialTouchIndex;
		}

		// Token: 0x06006299 RID: 25241 RVA: 0x0007CA0B File Offset: 0x0007AC0B
		public GorillaSurfaceOverride GetSurfaceOverride(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).surfaceOverride;
		}

		// Token: 0x0600629A RID: 25242 RVA: 0x0007CA23 File Offset: 0x0007AC23
		public RaycastHit GetTouchHitInfo(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).hitInfo;
		}

		// Token: 0x0600629B RID: 25243 RVA: 0x0007CA3B File Offset: 0x0007AC3B
		public bool IsHandTouching(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).wasColliding;
		}

		// Token: 0x0600629C RID: 25244 RVA: 0x0007CA53 File Offset: 0x0007AC53
		public GorillaVelocityTracker GetHandVelocityTracker(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).velocityTracker;
		}

		// Token: 0x0600629D RID: 25245 RVA: 0x0007CA6B File Offset: 0x0007AC6B
		public GorillaVelocityTracker GetInteractPointVelocityTracker(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).interactPointVelocityTracker;
		}

		// Token: 0x0600629E RID: 25246 RVA: 0x0007CA83 File Offset: 0x0007AC83
		public Transform GetControllerTransform(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).controllerTransform;
		}

		// Token: 0x0600629F RID: 25247 RVA: 0x0007CA9B File Offset: 0x0007AC9B
		public Transform GetHandFollower(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).handFollower;
		}

		// Token: 0x060062A0 RID: 25248 RVA: 0x0007CAB3 File Offset: 0x0007ACB3
		public Vector3 GetHandOffset(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).handOffset;
		}

		// Token: 0x060062A1 RID: 25249 RVA: 0x0007CACB File Offset: 0x0007ACCB
		public Quaternion GetHandRotOffset(bool isLeftHand)
		{
			return (isLeftHand ? this.leftHand : this.rightHand).handRotOffset;
		}

		// Token: 0x060062A2 RID: 25250 RVA: 0x0007CAE3 File Offset: 0x0007ACE3
		public Vector3 GetHandPosition(bool isLeftHand, StiltID stiltID = StiltID.None)
		{
			return ((stiltID != StiltID.None) ? this.stiltStates[(int)stiltID] : (isLeftHand ? this.leftHand : this.rightHand)).lastPosition;
		}

		// Token: 0x060062A3 RID: 25251 RVA: 0x002404F4 File Offset: 0x0023E6F4
		public void GetHandTapData(bool isLeftHand, StiltID stiltID, out bool wasHandTouching, out bool wasSliding, out int handMatIndex, out GorillaSurfaceOverride surfaceOverride, out RaycastHit handHitInfo, out Vector3 handPosition, out GorillaVelocityTracker handVelocityTracker)
		{
			((stiltID != StiltID.None) ? this.stiltStates[(int)stiltID] : (isLeftHand ? this.leftHand : this.rightHand)).GetHandTapData(out wasHandTouching, out wasSliding, out handMatIndex, out surfaceOverride, out handHitInfo, out handPosition, out handVelocityTracker);
		}

		// Token: 0x060062A4 RID: 25252 RVA: 0x0007CB0D File Offset: 0x0007AD0D
		public void SetHandOffsets(bool isLeftHand, Vector3 handOffset, Quaternion handRotOffset)
		{
			if (isLeftHand)
			{
				this.leftHand.handOffset = handOffset;
				this.leftHand.handRotOffset = handRotOffset;
				return;
			}
			this.rightHand.handOffset = handOffset;
			this.rightHand.handRotOffset = handRotOffset;
		}

		// Token: 0x17000951 RID: 2385
		// (get) Token: 0x060062A5 RID: 25253 RVA: 0x0007CB43 File Offset: 0x0007AD43
		public Vector3 InstantaneousVelocity
		{
			get
			{
				return this.currentVelocity;
			}
		}

		// Token: 0x17000952 RID: 2386
		// (get) Token: 0x060062A6 RID: 25254 RVA: 0x0007CB4B File Offset: 0x0007AD4B
		public Vector3 AveragedVelocity
		{
			get
			{
				return this.averagedVelocity;
			}
		}

		// Token: 0x17000953 RID: 2387
		// (get) Token: 0x060062A7 RID: 25255 RVA: 0x0007CB53 File Offset: 0x0007AD53
		public Transform CosmeticsHeadTarget
		{
			get
			{
				return this.cosmeticsHeadTarget;
			}
		}

		// Token: 0x17000954 RID: 2388
		// (get) Token: 0x060062A8 RID: 25256 RVA: 0x0007CB5B File Offset: 0x0007AD5B
		public float scale
		{
			get
			{
				return this.scaleMultiplier * this.nativeScale;
			}
		}

		// Token: 0x17000955 RID: 2389
		// (get) Token: 0x060062A9 RID: 25257 RVA: 0x0007CB6A File Offset: 0x0007AD6A
		public float NativeScale
		{
			get
			{
				return this.nativeScale;
			}
		}

		// Token: 0x17000956 RID: 2390
		// (get) Token: 0x060062AA RID: 25258 RVA: 0x0007CB72 File Offset: 0x0007AD72
		public float ScaleMultiplier
		{
			get
			{
				return this.scaleMultiplier;
			}
		}

		// Token: 0x060062AB RID: 25259 RVA: 0x0007CB7A File Offset: 0x0007AD7A
		public void SetScaleMultiplier(float s)
		{
			this.scaleMultiplier = s;
		}

		// Token: 0x060062AC RID: 25260 RVA: 0x0024053C File Offset: 0x0023E73C
		public void SetNativeScale(NativeSizeChangerSettings s)
		{
			float num = this.nativeScale;
			if (s != null && s.playerSizeScale > 0f && s.playerSizeScale != 1f)
			{
				this.activeSizeChangerSettings = s;
			}
			else
			{
				this.activeSizeChangerSettings = null;
			}
			if (this.activeSizeChangerSettings == null)
			{
				this.nativeScale = 1f;
			}
			else
			{
				this.nativeScale = this.activeSizeChangerSettings.playerSizeScale;
			}
			if (num != this.nativeScale && NetworkSystem.Instance.InRoom)
			{
				GorillaTagger.Instance.myVRRig != null;
			}
		}

		// Token: 0x17000957 RID: 2391
		// (get) Token: 0x060062AD RID: 25261 RVA: 0x0007CB83 File Offset: 0x0007AD83
		public bool IsDefaultScale
		{
			get
			{
				return Mathf.Abs(1f - this.scale) < 0.001f;
			}
		}

		// Token: 0x17000958 RID: 2392
		// (get) Token: 0x060062AE RID: 25262 RVA: 0x0007CB9D File Offset: 0x0007AD9D
		public bool turnedThisFrame
		{
			get
			{
				return this.degreesTurnedThisFrame != 0f;
			}
		}

		// Token: 0x17000959 RID: 2393
		// (get) Token: 0x060062AF RID: 25263 RVA: 0x0007CBAF File Offset: 0x0007ADAF
		public List<GTPlayer.MaterialData> materialData
		{
			get
			{
				return this.materialDatasSO.datas;
			}
		}

		// Token: 0x1700095A RID: 2394
		// (get) Token: 0x060062B0 RID: 25264 RVA: 0x0007CBBC File Offset: 0x0007ADBC
		// (set) Token: 0x060062B1 RID: 25265 RVA: 0x0007CBC4 File Offset: 0x0007ADC4
		protected bool IsFrozen { get; set; }

		// Token: 0x1700095B RID: 2395
		// (get) Token: 0x060062B2 RID: 25266 RVA: 0x0007CBCD File Offset: 0x0007ADCD
		public List<WaterVolume> HeadOverlappingWaterVolumes
		{
			get
			{
				return this.headOverlappingWaterVolumes;
			}
		}

		// Token: 0x1700095C RID: 2396
		// (get) Token: 0x060062B3 RID: 25267 RVA: 0x0007CBD5 File Offset: 0x0007ADD5
		public bool InWater
		{
			get
			{
				return this.bodyInWater;
			}
		}

		// Token: 0x1700095D RID: 2397
		// (get) Token: 0x060062B4 RID: 25268 RVA: 0x0007CBDD File Offset: 0x0007ADDD
		public bool HeadInWater
		{
			get
			{
				return this.headInWater;
			}
		}

		// Token: 0x1700095E RID: 2398
		// (get) Token: 0x060062B5 RID: 25269 RVA: 0x0007CBE5 File Offset: 0x0007ADE5
		public WaterVolume CurrentWaterVolume
		{
			get
			{
				if (this.bodyOverlappingWaterVolumes.Count <= 0)
				{
					return null;
				}
				return this.bodyOverlappingWaterVolumes[0];
			}
		}

		// Token: 0x1700095F RID: 2399
		// (get) Token: 0x060062B6 RID: 25270 RVA: 0x0007CC03 File Offset: 0x0007AE03
		public WaterVolume.SurfaceQuery WaterSurfaceForHead
		{
			get
			{
				return this.waterSurfaceForHead;
			}
		}

		// Token: 0x17000960 RID: 2400
		// (get) Token: 0x060062B7 RID: 25271 RVA: 0x0007CC0B File Offset: 0x0007AE0B
		public WaterVolume LeftHandWaterVolume
		{
			get
			{
				return this.leftHandWaterVolume;
			}
		}

		// Token: 0x17000961 RID: 2401
		// (get) Token: 0x060062B8 RID: 25272 RVA: 0x0007CC13 File Offset: 0x0007AE13
		public WaterVolume RightHandWaterVolume
		{
			get
			{
				return this.rightHandWaterVolume;
			}
		}

		// Token: 0x17000962 RID: 2402
		// (get) Token: 0x060062B9 RID: 25273 RVA: 0x0007CC1B File Offset: 0x0007AE1B
		public WaterVolume.SurfaceQuery LeftHandWaterSurface
		{
			get
			{
				return this.leftHandWaterSurface;
			}
		}

		// Token: 0x17000963 RID: 2403
		// (get) Token: 0x060062BA RID: 25274 RVA: 0x0007CC23 File Offset: 0x0007AE23
		public WaterVolume.SurfaceQuery RightHandWaterSurface
		{
			get
			{
				return this.rightHandWaterSurface;
			}
		}

		// Token: 0x17000964 RID: 2404
		// (get) Token: 0x060062BB RID: 25275 RVA: 0x0007CC2B File Offset: 0x0007AE2B
		public Vector3 LastLeftHandPosition
		{
			get
			{
				return this.leftHand.lastPosition;
			}
		}

		// Token: 0x17000965 RID: 2405
		// (get) Token: 0x060062BC RID: 25276 RVA: 0x0007CC38 File Offset: 0x0007AE38
		public Vector3 LastRightHandPosition
		{
			get
			{
				return this.rightHand.lastPosition;
			}
		}

		// Token: 0x17000966 RID: 2406
		// (get) Token: 0x060062BD RID: 25277 RVA: 0x0007CC45 File Offset: 0x0007AE45
		public Vector3 RigidbodyVelocity
		{
			get
			{
				return this.playerRigidBody.linearVelocity;
			}
		}

		// Token: 0x17000967 RID: 2407
		// (get) Token: 0x060062BE RID: 25278 RVA: 0x0007CC52 File Offset: 0x0007AE52
		public Vector3 HeadCenterPosition
		{
			get
			{
				return this.headCollider.transform.position + this.headCollider.transform.rotation * new Vector3(0f, 0f, -0.11f);
			}
		}

		// Token: 0x17000968 RID: 2408
		// (get) Token: 0x060062BF RID: 25279 RVA: 0x0007CC92 File Offset: 0x0007AE92
		public bool HandContactingSurface
		{
			get
			{
				return this.leftHand.isColliding || this.rightHand.isColliding;
			}
		}

		// Token: 0x17000969 RID: 2409
		// (get) Token: 0x060062C0 RID: 25280 RVA: 0x0007CCAE File Offset: 0x0007AEAE
		public bool BodyOnGround
		{
			get
			{
				return this.bodyGroundContactTime >= Time.time - 0.05f;
			}
		}

		// Token: 0x1700096A RID: 2410
		// (get) Token: 0x060062C1 RID: 25281 RVA: 0x0007CCC6 File Offset: 0x0007AEC6
		public bool IsGroundedHand
		{
			get
			{
				return this.HandContactingSurface || this.isClimbing || this.leftHand.isHolding || this.rightHand.isHolding;
			}
		}

		// Token: 0x1700096B RID: 2411
		// (get) Token: 0x060062C2 RID: 25282 RVA: 0x0007CCF2 File Offset: 0x0007AEF2
		public bool IsGroundedButt
		{
			get
			{
				return this.BodyOnGround;
			}
		}

		// Token: 0x1700096C RID: 2412
		// (get) Token: 0x060062C3 RID: 25283 RVA: 0x0007CCFA File Offset: 0x0007AEFA
		// (set) Token: 0x060062C4 RID: 25284 RVA: 0x0007CD02 File Offset: 0x0007AF02
		public int ThrusterActiveAtFrame { get; set; }

		// Token: 0x1700096D RID: 2413
		// (get) Token: 0x060062C5 RID: 25285 RVA: 0x0007CD0B File Offset: 0x0007AF0B
		public bool IsThrusterActive
		{
			get
			{
				return this.ThrusterActiveAtFrame == Time.frameCount;
			}
		}

		// Token: 0x1700096E RID: 2414
		// (set) Token: 0x060062C6 RID: 25286 RVA: 0x0007CD1A File Offset: 0x0007AF1A
		public Quaternion PlayerRotationOverride
		{
			set
			{
				this.playerRotationOverride = value;
				this.playerRotationOverrideFrame = Time.frameCount;
			}
		}

		// Token: 0x1700096F RID: 2415
		// (get) Token: 0x060062C7 RID: 25287 RVA: 0x0007CD2E File Offset: 0x0007AF2E
		// (set) Token: 0x060062C8 RID: 25288 RVA: 0x0007CD36 File Offset: 0x0007AF36
		public bool IsBodySliding { get; set; }

		// Token: 0x17000970 RID: 2416
		// (get) Token: 0x060062C9 RID: 25289 RVA: 0x0007CD3F File Offset: 0x0007AF3F
		public GorillaClimbable CurrentClimbable
		{
			get
			{
				return this.currentClimbable;
			}
		}

		// Token: 0x17000971 RID: 2417
		// (get) Token: 0x060062CA RID: 25290 RVA: 0x0007CD47 File Offset: 0x0007AF47
		public GorillaHandClimber CurrentClimber
		{
			get
			{
				return this.currentClimber;
			}
		}

		// Token: 0x17000972 RID: 2418
		// (get) Token: 0x060062CB RID: 25291 RVA: 0x0007CD4F File Offset: 0x0007AF4F
		// (set) Token: 0x060062CC RID: 25292 RVA: 0x0007CD57 File Offset: 0x0007AF57
		public float jumpMultiplier
		{
			get
			{
				return this._jumpMultiplier;
			}
			set
			{
				this._jumpMultiplier = value;
			}
		}

		// Token: 0x17000973 RID: 2419
		// (get) Token: 0x060062CD RID: 25293 RVA: 0x0007CD60 File Offset: 0x0007AF60
		// (set) Token: 0x060062CE RID: 25294 RVA: 0x0007CD68 File Offset: 0x0007AF68
		public float LastTouchedGroundAtNetworkTime { get; private set; }

		// Token: 0x17000974 RID: 2420
		// (get) Token: 0x060062CF RID: 25295 RVA: 0x0007CD71 File Offset: 0x0007AF71
		// (set) Token: 0x060062D0 RID: 25296 RVA: 0x0007CD79 File Offset: 0x0007AF79
		public float LastHandTouchedGroundAtNetworkTime { get; private set; }

		// Token: 0x060062D1 RID: 25297 RVA: 0x002405C8 File Offset: 0x0023E7C8
		public void EnableStilt(StiltID stiltID, bool isLeftHand, Vector3 currentTipWorldPos, float maxArmLength, bool canTag, bool canStun, float customBoostFactor = 0f, GorillaVelocityTracker velocityTracker = null)
		{
			this.stiltStates[(int)stiltID] = new GTPlayer.HandState
			{
				isActive = true,
				controllerTransform = (isLeftHand ? this.leftHand : this.rightHand).controllerTransform,
				velocityTracker = ((velocityTracker != null) ? velocityTracker : (isLeftHand ? this.leftHand : this.rightHand).velocityTracker),
				handRotOffset = Quaternion.identity,
				canTag = canTag,
				canStun = canStun,
				customBoostFactor = customBoostFactor,
				hasCustomBoost = (customBoostFactor > 0f)
			};
			this.stiltStates[(int)stiltID].Init(this, isLeftHand, maxArmLength);
			this.UpdateStiltOffset(stiltID, currentTipWorldPos);
		}

		// Token: 0x060062D2 RID: 25298 RVA: 0x0007CD82 File Offset: 0x0007AF82
		public void DisableStilt(StiltID stiltID)
		{
			this.stiltStates[(int)stiltID].isActive = false;
		}

		// Token: 0x060062D3 RID: 25299 RVA: 0x0007CD96 File Offset: 0x0007AF96
		public void UpdateStiltOffset(StiltID stiltID, Vector3 currentTipWorldPos)
		{
			this.stiltStates[(int)stiltID].handOffset = this.stiltStates[(int)stiltID].controllerTransform.InverseTransformPoint(currentTipWorldPos);
		}

		// Token: 0x060062D4 RID: 25300 RVA: 0x00240690 File Offset: 0x0023E890
		private void Awake()
		{
			if (GTPlayer._instance != null && GTPlayer._instance != this)
			{
				Object.Destroy(base.gameObject);
			}
			else
			{
				GTPlayer._instance = this;
				GTPlayer.hasInstance = true;
			}
			this.InitializeValues();
			this.playerRigidbodyInterpolationDefault = this.playerRigidBody.interpolation;
			this.playerRigidBody.maxAngularVelocity = 0f;
			this.bodyOffsetVector = new Vector3(0f, -this.bodyCollider.height / 2f, 0f);
			this.bodyInitialHeight = this.bodyCollider.height;
			this.bodyInitialRadius = this.bodyCollider.radius;
			this.rayCastNonAllocColliders = new RaycastHit[5];
			this.crazyCheckVectors = new Vector3[7];
			this.emptyHit = default(RaycastHit);
			this.crazyCheckVectors[0] = Vector3.up;
			this.crazyCheckVectors[1] = Vector3.down;
			this.crazyCheckVectors[2] = Vector3.left;
			this.crazyCheckVectors[3] = Vector3.right;
			this.crazyCheckVectors[4] = Vector3.forward;
			this.crazyCheckVectors[5] = Vector3.back;
			this.crazyCheckVectors[6] = Vector3.zero;
			if (this.controllerState == null)
			{
				this.controllerState = base.GetComponent<ConnectedControllerHandler>();
			}
			this.layerChanger = base.GetComponent<LayerChanger>();
			this.bodyTouchedSurfaces = new Dictionary<GameObject, PhysicsMaterial>();
			if (Application.isPlaying)
			{
				Application.onBeforeRender += this.OnBeforeRenderInit;
			}
		}

		// Token: 0x060062D5 RID: 25301 RVA: 0x00240824 File Offset: 0x0023EA24
		protected void Start()
		{
			if (this.mainCamera == null)
			{
				this.mainCamera = Camera.main;
			}
			this.mainCamera.farClipPlane = 500f;
			this.lastScale = this.scale;
			this.layerChanger.InitializeLayers(base.transform);
			float degrees = Quaternion.Angle(Quaternion.identity, GorillaTagger.Instance.offlineVRRig.transform.rotation) * Mathf.Sign(Vector3.Dot(Vector3.up, GorillaTagger.Instance.offlineVRRig.transform.right));
			this.Turn(degrees);
		}

		// Token: 0x060062D6 RID: 25302 RVA: 0x0007CDC0 File Offset: 0x0007AFC0
		protected void OnDestroy()
		{
			if (GTPlayer._instance == this)
			{
				GTPlayer._instance = null;
				GTPlayer.hasInstance = false;
			}
			if (this.climbHelper)
			{
				Object.Destroy(this.climbHelper.gameObject);
			}
		}

		// Token: 0x060062D7 RID: 25303 RVA: 0x002408C4 File Offset: 0x0023EAC4
		public void InitializeValues()
		{
			Physics.SyncTransforms();
			this.playerRigidBody = base.GetComponent<Rigidbody>();
			this.velocityHistory = new Vector3[this.velocityHistorySize];
			this.slideAverageHistory = new Vector3[this.velocityHistorySize];
			for (int i = 0; i < this.velocityHistory.Length; i++)
			{
				this.velocityHistory[i] = Vector3.zero;
				this.slideAverageHistory[i] = Vector3.zero;
			}
			this.leftHand.Init(this, true, this.maxArmLength);
			this.rightHand.Init(this, false, this.maxArmLength);
			this.lastHeadPosition = this.headCollider.transform.position;
			this.velocityIndex = 0;
			this.averagedVelocity = Vector3.zero;
			this.slideVelocity = Vector3.zero;
			this.lastPosition = base.transform.position;
			this.lastRealTime = Time.realtimeSinceStartup;
			this.lastOpenHeadPosition = this.headCollider.transform.position;
			this.bodyCollider.transform.position = this.PositionWithOffset(this.headCollider.transform, this.bodyOffset) + this.bodyOffsetVector;
			this.bodyCollider.transform.eulerAngles = new Vector3(0f, this.headCollider.transform.eulerAngles.y, 0f);
			this.ForceRigidBodySync();
		}

		// Token: 0x060062D8 RID: 25304 RVA: 0x0007CDF8 File Offset: 0x0007AFF8
		public void SetHalloweenLevitation(float levitateStrength, float levitateDuration, float levitateBlendOutDuration, float levitateBonusStrength, float levitateBonusOffAtYSpeed, float levitateBonusFullAtYSpeed)
		{
			this.halloweenLevitationStrength = levitateStrength;
			this.halloweenLevitationFullStrengthDuration = levitateDuration;
			this.halloweenLevitationTotalDuration = levitateDuration + levitateBlendOutDuration;
			this.halloweenLevitateBonusFullAtYSpeed = levitateBonusFullAtYSpeed;
			this.halloweenLevitateBonusOffAtYSpeed = levitateBonusFullAtYSpeed;
			this.halloweenLevitationBonusStrength = levitateBonusStrength;
		}

		// Token: 0x060062D9 RID: 25305 RVA: 0x0007CE29 File Offset: 0x0007B029
		public void TeleportToTrain(bool enable)
		{
			this.teleportToTrain = enable;
		}

		// Token: 0x060062DA RID: 25306 RVA: 0x00240A30 File Offset: 0x0023EC30
		public void TeleportTo(Vector3 position, Quaternion rotation, bool keepVelocity = false, bool center = false)
		{
			if (center)
			{
				Vector3 position2 = base.transform.position;
				Vector3 b = this.mainCamera.transform.position - position2;
				position -= b;
			}
			this.ClearHandHolds();
			if (this.playerRigidBody != null)
			{
				this.playerRigidBody.isKinematic = true;
				this.playerRigidBody.position = position;
				this.playerRigidBody.rotation = rotation;
				this.playerRigidBody.isKinematic = false;
			}
			this.playerRigidBody.position = position;
			this.playerRigidBody.rotation = rotation;
			base.transform.position = position;
			base.transform.rotation = rotation;
			this.lastHeadPosition = this.headCollider.transform.position;
			this.lastPosition = position;
			this.lastOpenHeadPosition = this.headCollider.transform.position;
			this.leftHand.OnTeleport();
			this.rightHand.OnTeleport();
			if (!keepVelocity)
			{
				this.playerRigidBody.linearVelocity = Vector3.zero;
			}
			this.bodyCollider.transform.position = this.PositionWithOffset(this.headCollider.transform, this.bodyOffset) + this.bodyOffsetVector;
			this.bodyCollider.transform.eulerAngles = new Vector3(0f, this.headCollider.transform.eulerAngles.y, 0f);
			Physics.SyncTransforms();
			GorillaTagger.Instance.offlineVRRig.transform.position = position;
			GorillaTagger.Instance.offlineVRRig.leftHandLink.BreakLink();
			GorillaTagger.Instance.offlineVRRig.rightHandLink.BreakLink();
			this.ForceRigidBodySync();
		}

		// Token: 0x060062DB RID: 25307 RVA: 0x00240BEC File Offset: 0x0023EDEC
		public void TeleportTo(Transform destination, bool matchDestinationRotation = true, bool maintainVelocity = true)
		{
			Vector3 position = base.transform.position;
			Vector3 b = this.mainCamera.transform.position - position;
			Vector3 position2 = destination.position - b;
			float num = destination.rotation.eulerAngles.y - this.mainCamera.transform.rotation.eulerAngles.y;
			Vector3 playerVelocity = this.currentVelocity;
			if (!maintainVelocity)
			{
				this.SetPlayerVelocity(Vector3.zero);
			}
			else if (matchDestinationRotation)
			{
				playerVelocity = Quaternion.AngleAxis(num, base.transform.up) * this.currentVelocity;
				this.SetPlayerVelocity(playerVelocity);
			}
			if (matchDestinationRotation)
			{
				this.Turn(num);
			}
			this.TeleportTo(position2, base.transform.rotation, false, false);
			if (maintainVelocity)
			{
				this.SetPlayerVelocity(playerVelocity);
			}
			this.ForceRigidBodySync();
		}

		// Token: 0x060062DC RID: 25308 RVA: 0x00240CD0 File Offset: 0x0023EED0
		public void AddForce(Vector3 force, ForceMode mode)
		{
			if (mode == ForceMode.VelocityChange)
			{
				this.playerRigidBody.AddForce(force * this.playerRigidBody.mass, ForceMode.Impulse);
				return;
			}
			if (mode == ForceMode.Acceleration)
			{
				this.playerRigidBody.AddForce(force * this.playerRigidBody.mass, ForceMode.Force);
				return;
			}
			this.playerRigidBody.AddForce(force, mode);
		}

		// Token: 0x060062DD RID: 25309 RVA: 0x00240D30 File Offset: 0x0023EF30
		public void SetPlayerVelocity(Vector3 newVelocity)
		{
			for (int i = 0; i < this.velocityHistory.Length; i++)
			{
				this.velocityHistory[i] = newVelocity;
			}
			this.playerRigidBody.AddForce(newVelocity - this.playerRigidBody.linearVelocity, ForceMode.VelocityChange);
		}

		// Token: 0x060062DE RID: 25310 RVA: 0x0007CE32 File Offset: 0x0007B032
		public void SetGravityOverride(Object caller, Action<GTPlayer> gravityFunction)
		{
			this.gravityOverrides[caller] = gravityFunction;
		}

		// Token: 0x060062DF RID: 25311 RVA: 0x0007CE41 File Offset: 0x0007B041
		public void UnsetGravityOverride(Object caller)
		{
			this.gravityOverrides.Remove(caller);
		}

		// Token: 0x060062E0 RID: 25312 RVA: 0x00240D7C File Offset: 0x0023EF7C
		private void ApplyGravityOverrides()
		{
			foreach (KeyValuePair<Object, Action<GTPlayer>> keyValuePair in this.gravityOverrides)
			{
				keyValuePair.Value(this);
			}
		}

		// Token: 0x060062E1 RID: 25313 RVA: 0x00240DD8 File Offset: 0x0023EFD8
		public void ApplyKnockback(Vector3 direction, float speed, bool forceOffTheGround = false)
		{
			if (forceOffTheGround)
			{
				if (this.leftHand.wasColliding || this.rightHand.wasColliding)
				{
					this.leftHand.wasColliding = false;
					this.rightHand.wasColliding = false;
					this.playerRigidBody.transform.position += this.minimumRaycastDistance * this.scale * Vector3.up;
				}
				this.didAJump = true;
				this.SetMaximumSlipThisFrame();
			}
			if (speed > 0.01f)
			{
				float num = Vector3.Dot(this.averagedVelocity, direction);
				float d = Mathf.InverseLerp(1.5f, 0.5f, num / speed);
				Vector3 vector = this.averagedVelocity + direction * speed * d;
				this.playerRigidBody.linearVelocity = vector;
				for (int i = 0; i < this.velocityHistory.Length; i++)
				{
					this.velocityHistory[i] = vector;
				}
			}
		}

		// Token: 0x060062E2 RID: 25314 RVA: 0x00240EC8 File Offset: 0x0023F0C8
		public void FixedUpdate()
		{
			this.AntiTeleportTechnology();
			this.IsFrozen = (GorillaTagger.Instance.offlineVRRig.IsFrozen || this.debugFreezeTag);
			bool isDefaultScale = this.IsDefaultScale;
			this.playerRigidBody.useGravity = false;
			if (this.gravityOverrides.Count > 0)
			{
				this.ApplyGravityOverrides();
			}
			else
			{
				if (!this.isClimbing)
				{
					this.playerRigidBody.AddForce(Physics.gravity * this.scale * this.playerRigidBody.mass, ForceMode.Force);
				}
				if (this.halloweenLevitationBonusStrength > 0f || this.halloweenLevitationStrength > 0f)
				{
					float num = Time.time - this.lastTouchedGroundTimestamp;
					if (num < this.halloweenLevitationTotalDuration)
					{
						this.playerRigidBody.AddForce(Vector3.up * this.halloweenLevitationStrength * Mathf.InverseLerp(this.halloweenLevitationFullStrengthDuration, this.halloweenLevitationTotalDuration, num) * this.playerRigidBody.mass, ForceMode.Force);
					}
					float y = this.playerRigidBody.linearVelocity.y;
					if (y <= this.halloweenLevitateBonusFullAtYSpeed)
					{
						this.playerRigidBody.AddForce(Vector3.up * this.halloweenLevitationBonusStrength * this.playerRigidBody.mass, ForceMode.Force);
					}
					else if (y <= this.halloweenLevitateBonusOffAtYSpeed)
					{
						Mathf.InverseLerp(this.halloweenLevitateBonusOffAtYSpeed, this.halloweenLevitateBonusFullAtYSpeed, this.playerRigidBody.linearVelocity.y);
						this.playerRigidBody.AddForce(Vector3.up * this.halloweenLevitationBonusStrength * Mathf.InverseLerp(this.halloweenLevitateBonusOffAtYSpeed, this.halloweenLevitateBonusFullAtYSpeed, this.playerRigidBody.linearVelocity.y) * this.playerRigidBody.mass, ForceMode.Force);
					}
				}
			}
			if (this.enableHoverMode)
			{
				this.playerRigidBody.linearVelocity = this.HoverboardFixedUpdate(this.playerRigidBody.linearVelocity);
			}
			else
			{
				this.didHoverLastFrame = false;
			}
			float fixedDeltaTime = Time.fixedDeltaTime;
			this.bodyInWater = false;
			Vector3 lhs = this.swimmingVelocity;
			this.swimmingVelocity = Vector3.MoveTowards(this.swimmingVelocity, Vector3.zero, this.swimmingParams.swimmingVelocityOutOfWaterDrainRate * fixedDeltaTime);
			this.leftHandNonDiveHapticsAmount = 0f;
			this.rightHandNonDiveHapticsAmount = 0f;
			if (this.bodyOverlappingWaterVolumes.Count > 0)
			{
				WaterVolume waterVolume = null;
				float num2 = float.MinValue;
				Vector3 vector = this.headCollider.transform.position + Vector3.down * this.swimmingParams.floatingWaterLevelBelowHead * this.scale;
				this.activeWaterCurrents.Clear();
				for (int i = 0; i < this.bodyOverlappingWaterVolumes.Count; i++)
				{
					WaterVolume.SurfaceQuery surfaceQuery;
					if (this.bodyOverlappingWaterVolumes[i].GetSurfaceQueryForPoint(vector, out surfaceQuery, false))
					{
						float num3 = Vector3.Dot(surfaceQuery.surfacePoint - vector, surfaceQuery.surfaceNormal);
						if (num3 > num2)
						{
							num2 = num3;
							waterVolume = this.bodyOverlappingWaterVolumes[i];
							this.waterSurfaceForHead = surfaceQuery;
						}
						WaterCurrent waterCurrent = this.bodyOverlappingWaterVolumes[i].Current;
						if (waterCurrent != null && num3 > 0f && !this.activeWaterCurrents.Contains(waterCurrent))
						{
							this.activeWaterCurrents.Add(waterCurrent);
						}
					}
				}
				if (waterVolume != null)
				{
					Vector3 linearVelocity = this.playerRigidBody.linearVelocity;
					float magnitude = linearVelocity.magnitude;
					bool flag = this.headInWater;
					this.headInWater = (this.headCollider.transform.position.y < this.waterSurfaceForHead.surfacePoint.y && this.headCollider.transform.position.y > this.waterSurfaceForHead.surfacePoint.y - this.waterSurfaceForHead.maxDepth);
					if (this.headInWater && !flag)
					{
						this.audioSetToUnderwater = true;
						this.audioManager.SetMixerSnapshot(this.audioManager.underwaterSnapshot, 0.1f);
					}
					else if (!this.headInWater && flag)
					{
						this.audioSetToUnderwater = false;
						this.audioManager.UnsetMixerSnapshot(0.1f);
					}
					this.bodyInWater = (vector.y < this.waterSurfaceForHead.surfacePoint.y && vector.y > this.waterSurfaceForHead.surfacePoint.y - this.waterSurfaceForHead.maxDepth);
					if (this.bodyInWater)
					{
						GTPlayer.LiquidProperties liquidProperties = this.liquidPropertiesList[(int)waterVolume.LiquidType];
						if (waterVolume != null)
						{
							float d;
							if (this.swimmingParams.extendBouyancyFromSpeed)
							{
								float time = Mathf.Clamp(Vector3.Dot(linearVelocity / this.scale, this.waterSurfaceForHead.surfaceNormal), this.swimmingParams.speedToBouyancyExtensionMinMax.x, this.swimmingParams.speedToBouyancyExtensionMinMax.y);
								float b = this.swimmingParams.speedToBouyancyExtension.Evaluate(time);
								this.buoyancyExtension = Mathf.Max(this.buoyancyExtension, b);
								float num4 = Mathf.InverseLerp(0f, this.swimmingParams.buoyancyFadeDist + this.buoyancyExtension, num2 / this.scale + this.buoyancyExtension);
								this.buoyancyExtension = Spring.DamperDecayExact(this.buoyancyExtension, this.swimmingParams.buoyancyExtensionDecayHalflife, fixedDeltaTime, 1E-05f);
								d = num4;
							}
							else
							{
								d = Mathf.InverseLerp(0f, this.swimmingParams.buoyancyFadeDist, num2 / this.scale);
							}
							Vector3 a = Physics.gravity * this.scale;
							Vector3 a2 = liquidProperties.buoyancy * -a * d;
							if (this.IsFrozen && GorillaGameManager.instance is GorillaFreezeTagManager)
							{
								a2 *= this.frozenBodyBuoyancyFactor;
							}
							this.playerRigidBody.AddForce(a2 * this.playerRigidBody.mass, ForceMode.Force);
						}
						Vector3 vector2 = Vector3.zero;
						Vector3 vector3 = Vector3.zero;
						for (int j = 0; j < this.activeWaterCurrents.Count; j++)
						{
							WaterCurrent waterCurrent2 = this.activeWaterCurrents[j];
							Vector3 startingVelocity = linearVelocity + vector2;
							Vector3 b2;
							Vector3 b3;
							if (waterCurrent2.GetCurrentAtPoint(this.bodyCollider.transform.position, startingVelocity, fixedDeltaTime, out b2, out b3))
							{
								vector3 += b2;
								vector2 += b3;
							}
						}
						if (magnitude > Mathf.Epsilon)
						{
							float num5 = 0.01f;
							Vector3 vector4 = linearVelocity / magnitude;
							Vector3 right = this.leftHand.handFollower.right;
							Vector3 dir = -this.rightHand.handFollower.right;
							Vector3 forward = this.leftHand.handFollower.forward;
							Vector3 forward2 = this.rightHand.handFollower.forward;
							Vector3 a3 = vector4;
							float num6 = 0f;
							float num7 = 0f;
							float num8 = 0f;
							if (this.swimmingParams.applyDiveSteering && !this.disableMovement && isDefaultScale)
							{
								float value = Vector3.Dot(linearVelocity - vector3, vector4);
								float time2 = Mathf.Clamp(value, this.swimmingParams.swimSpeedToRedirectAmountMinMax.x, this.swimmingParams.swimSpeedToRedirectAmountMinMax.y);
								float b4 = this.swimmingParams.swimSpeedToRedirectAmount.Evaluate(time2);
								time2 = Mathf.Clamp(value, this.swimmingParams.swimSpeedToMaxRedirectAngleMinMax.x, this.swimmingParams.swimSpeedToMaxRedirectAngleMinMax.y);
								float num9 = this.swimmingParams.swimSpeedToMaxRedirectAngle.Evaluate(time2);
								float value2 = Mathf.Acos(Vector3.Dot(vector4, forward)) / 3.1415927f * -2f + 1f;
								float value3 = Mathf.Acos(Vector3.Dot(vector4, forward2)) / 3.1415927f * -2f + 1f;
								float num10 = Mathf.Clamp(value2, this.swimmingParams.palmFacingToRedirectAmountMinMax.x, this.swimmingParams.palmFacingToRedirectAmountMinMax.y);
								float num11 = Mathf.Clamp(value3, this.swimmingParams.palmFacingToRedirectAmountMinMax.x, this.swimmingParams.palmFacingToRedirectAmountMinMax.y);
								float a4 = (!float.IsNaN(num10)) ? this.swimmingParams.palmFacingToRedirectAmount.Evaluate(num10) : 0f;
								float a5 = (!float.IsNaN(num11)) ? this.swimmingParams.palmFacingToRedirectAmount.Evaluate(num11) : 0f;
								Vector3 a6 = Vector3.ProjectOnPlane(vector4, right);
								Vector3 a7 = Vector3.ProjectOnPlane(vector4, right);
								float num12 = Mathf.Min(a6.magnitude, 1f);
								float num13 = Mathf.Min(a7.magnitude, 1f);
								float magnitude2 = this.leftHand.velocityTracker.GetAverageVelocity(false, this.swimmingParams.diveVelocityAveragingWindow, false).magnitude;
								float magnitude3 = this.rightHand.velocityTracker.GetAverageVelocity(false, this.swimmingParams.diveVelocityAveragingWindow, false).magnitude;
								float time3 = Mathf.Clamp(magnitude2, this.swimmingParams.handSpeedToRedirectAmountMinMax.x, this.swimmingParams.handSpeedToRedirectAmountMinMax.y);
								float time4 = Mathf.Clamp(magnitude3, this.swimmingParams.handSpeedToRedirectAmountMinMax.x, this.swimmingParams.handSpeedToRedirectAmountMinMax.y);
								float a8 = this.swimmingParams.handSpeedToRedirectAmount.Evaluate(time3);
								float a9 = this.swimmingParams.handSpeedToRedirectAmount.Evaluate(time4);
								float averageSpeedChangeMagnitudeInDirection = this.leftHand.velocityTracker.GetAverageSpeedChangeMagnitudeInDirection(right, false, this.swimmingParams.diveVelocityAveragingWindow);
								float averageSpeedChangeMagnitudeInDirection2 = this.rightHand.velocityTracker.GetAverageSpeedChangeMagnitudeInDirection(dir, false, this.swimmingParams.diveVelocityAveragingWindow);
								float time5 = Mathf.Clamp(averageSpeedChangeMagnitudeInDirection, this.swimmingParams.handAccelToRedirectAmountMinMax.x, this.swimmingParams.handAccelToRedirectAmountMinMax.y);
								float time6 = Mathf.Clamp(averageSpeedChangeMagnitudeInDirection2, this.swimmingParams.handAccelToRedirectAmountMinMax.x, this.swimmingParams.handAccelToRedirectAmountMinMax.y);
								float b5 = this.swimmingParams.handAccelToRedirectAmount.Evaluate(time5);
								float b6 = this.swimmingParams.handAccelToRedirectAmount.Evaluate(time6);
								num6 = Mathf.Min(a4, Mathf.Min(a8, b5));
								float num14 = (Vector3.Dot(vector4, forward) > 0f) ? (Mathf.Min(num6, b4) * num12) : 0f;
								num7 = Mathf.Min(a5, Mathf.Min(a9, b6));
								float num15 = (Vector3.Dot(vector4, forward2) > 0f) ? (Mathf.Min(num7, b4) * num13) : 0f;
								if (this.swimmingParams.reduceDiveSteeringBelowVelocityPlane)
								{
									Vector3 rhs;
									if (Vector3.Dot(this.headCollider.transform.up, vector4) > 0.95f)
									{
										rhs = -this.headCollider.transform.forward;
									}
									else
									{
										rhs = Vector3.Cross(Vector3.Cross(vector4, this.headCollider.transform.up), vector4).normalized;
									}
									Vector3 position = this.headCollider.transform.position;
									Vector3 lhs2 = position - this.leftHand.handFollower.position;
									Vector3 lhs3 = position - this.rightHand.handFollower.position;
									float reduceDiveSteeringBelowPlaneFadeStartDist = this.swimmingParams.reduceDiveSteeringBelowPlaneFadeStartDist;
									float reduceDiveSteeringBelowPlaneFadeEndDist = this.swimmingParams.reduceDiveSteeringBelowPlaneFadeEndDist;
									float f = Vector3.Dot(lhs2, Vector3.up);
									float f2 = Vector3.Dot(lhs3, Vector3.up);
									float f3 = Vector3.Dot(lhs2, rhs);
									float f4 = Vector3.Dot(lhs3, rhs);
									float num16 = 1f - Mathf.InverseLerp(reduceDiveSteeringBelowPlaneFadeStartDist, reduceDiveSteeringBelowPlaneFadeEndDist, Mathf.Min(Mathf.Abs(f), Mathf.Abs(f3)));
									float num17 = 1f - Mathf.InverseLerp(reduceDiveSteeringBelowPlaneFadeStartDist, reduceDiveSteeringBelowPlaneFadeEndDist, Mathf.Min(Mathf.Abs(f2), Mathf.Abs(f4)));
									num14 *= num16;
									num15 *= num17;
								}
								float num18 = num15 + num14;
								Vector3 vector5 = Vector3.zero;
								if (this.swimmingParams.applyDiveSteering && num18 > num5)
								{
									vector5 = ((num14 * a6 + num15 * a7) / num18).normalized;
									vector5 = Vector3.Lerp(vector4, vector5, num18);
									a3 = Vector3.RotateTowards(vector4, vector5, 0.017453292f * num9 * fixedDeltaTime, 0f);
								}
								else
								{
									a3 = vector4;
								}
								num8 = Mathf.Clamp01((num6 + num7) * 0.5f);
							}
							float num19 = Mathf.Clamp(Vector3.Dot(lhs, vector4), 0f, magnitude);
							float num20 = magnitude - num19;
							if (this.swimmingParams.applyDiveSwimVelocityConversion && !this.disableMovement && num8 > num5 && num19 < this.swimmingParams.diveMaxSwimVelocityConversion)
							{
								float num21 = Mathf.Min(this.swimmingParams.diveSwimVelocityConversionRate * fixedDeltaTime, num20) * num8;
								num19 += num21;
								num20 -= num21;
							}
							float halflife = this.swimmingParams.swimUnderWaterDampingHalfLife * liquidProperties.dampingFactor;
							float halflife2 = this.swimmingParams.baseUnderWaterDampingHalfLife * liquidProperties.dampingFactor;
							float num22 = Spring.DamperDecayExact(num19 / this.scale, halflife, fixedDeltaTime, 1E-05f) * this.scale;
							float num23 = Spring.DamperDecayExact(num20 / this.scale, halflife2, fixedDeltaTime, 1E-05f) * this.scale;
							if (this.swimmingParams.applyDiveDampingMultiplier && !this.disableMovement)
							{
								float t = Mathf.Lerp(1f, this.swimmingParams.diveDampingMultiplier, num8);
								num22 = Mathf.Lerp(num19, num22, t);
								num23 = Mathf.Lerp(num20, num23, t);
								float time7 = Mathf.Clamp((1f - num6) * (num19 + num20), this.swimmingParams.nonDiveDampingHapticsAmountMinMax.x + num5, this.swimmingParams.nonDiveDampingHapticsAmountMinMax.y - num5);
								float time8 = Mathf.Clamp((1f - num7) * (num19 + num20), this.swimmingParams.nonDiveDampingHapticsAmountMinMax.x + num5, this.swimmingParams.nonDiveDampingHapticsAmountMinMax.y - num5);
								this.leftHandNonDiveHapticsAmount = this.swimmingParams.nonDiveDampingHapticsAmount.Evaluate(time7);
								this.rightHandNonDiveHapticsAmount = this.swimmingParams.nonDiveDampingHapticsAmount.Evaluate(time8);
							}
							this.swimmingVelocity = num22 * a3 + vector2 * this.scale;
							this.playerRigidBody.linearVelocity = this.swimmingVelocity + num23 * a3;
						}
					}
				}
			}
			else if (this.audioSetToUnderwater)
			{
				this.audioSetToUnderwater = false;
				this.audioManager.UnsetMixerSnapshot(0.1f);
			}
			this.handleClimbing(Time.fixedDeltaTime);
			this.stuckHandsCheckFixedUpdate();
			this.FixedUpdate_HandHolds(Time.fixedDeltaTime);
		}

		// Token: 0x17000975 RID: 2421
		// (get) Token: 0x060062E3 RID: 25315 RVA: 0x0007CE50 File Offset: 0x0007B050
		// (set) Token: 0x060062E4 RID: 25316 RVA: 0x0007CE58 File Offset: 0x0007B058
		public bool isHoverAllowed { get; private set; }

		// Token: 0x17000976 RID: 2422
		// (get) Token: 0x060062E5 RID: 25317 RVA: 0x0007CE61 File Offset: 0x0007B061
		// (set) Token: 0x060062E6 RID: 25318 RVA: 0x0007CE69 File Offset: 0x0007B069
		public bool enableHoverMode { get; private set; }

		// Token: 0x060062E7 RID: 25319 RVA: 0x0007CE72 File Offset: 0x0007B072
		public void SetHoverboardPosRot(Vector3 worldPos, Quaternion worldRot)
		{
			this.hoverboardPlayerLocalPos = this.headCollider.transform.InverseTransformPoint(worldPos);
			this.hoverboardPlayerLocalRot = this.headCollider.transform.InverseTransformRotation(worldRot);
		}

		// Token: 0x060062E8 RID: 25320 RVA: 0x00241D98 File Offset: 0x0023FF98
		private void HoverboardLateUpdate()
		{
			Vector3 eulerAngles = this.headCollider.transform.eulerAngles;
			bool flag = false;
			for (int i = 0; i < this.hoverboardCasts.Length; i++)
			{
				GTPlayer.HoverBoardCast hoverBoardCast = this.hoverboardCasts[i];
				RaycastHit raycastHit;
				hoverBoardCast.didHit = Physics.SphereCast(new Ray(this.hoverboardVisual.transform.TransformPoint(hoverBoardCast.localOrigin), this.hoverboardVisual.transform.rotation * hoverBoardCast.localDirection), hoverBoardCast.sphereRadius, out raycastHit, hoverBoardCast.distance, this.locomotionEnabledLayers);
				if (hoverBoardCast.didHit)
				{
					HoverboardCantHover hoverboardCantHover;
					if (raycastHit.collider.TryGetComponent<HoverboardCantHover>(out hoverboardCantHover))
					{
						hoverBoardCast.didHit = false;
					}
					else
					{
						hoverBoardCast.pointHit = raycastHit.point;
						hoverBoardCast.normalHit = raycastHit.normal;
					}
				}
				this.hoverboardCasts[i] = hoverBoardCast;
				if (hoverBoardCast.didHit)
				{
					flag = true;
				}
			}
			this.hasHoverPoint = flag;
			this.bodyCollider.enabled = (this.bodyCollider.transform.position - this.hoverboardVisual.transform.TransformPoint(Vector3.up * this.hoverBodyCollisionRadiusUpOffset)).IsLongerThan(this.hoverBodyHasCollisionsOutsideRadius);
		}

		// Token: 0x060062E9 RID: 25321 RVA: 0x00241EE0 File Offset: 0x002400E0
		private Vector3 HoverboardFixedUpdate(Vector3 velocity)
		{
			this.hoverboardVisual.transform.position = this.headCollider.transform.TransformPoint(this.hoverboardPlayerLocalPos);
			this.hoverboardVisual.transform.rotation = this.headCollider.transform.TransformRotation(this.hoverboardPlayerLocalRot);
			if (this.didHoverLastFrame)
			{
				velocity += Vector3.up * this.hoverGeneralUpwardForce * Time.fixedDeltaTime;
			}
			Vector3 position = this.hoverboardVisual.transform.position;
			Vector3 a = position + velocity * Time.fixedDeltaTime;
			Vector3 vector = this.hoverboardVisual.transform.forward;
			Vector3 vector2 = this.hoverboardCasts[0].didHit ? this.hoverboardCasts[0].normalHit : Vector3.up;
			bool flag = false;
			for (int i = 0; i < this.hoverboardCasts.Length; i++)
			{
				GTPlayer.HoverBoardCast hoverBoardCast = this.hoverboardCasts[i];
				if (hoverBoardCast.didHit)
				{
					Vector3 b = position + Vector3.Project(hoverBoardCast.pointHit - position, vector);
					Vector3 b2 = a + Vector3.Project(hoverBoardCast.pointHit - position, vector);
					bool flag2 = hoverBoardCast.isSolid || Vector3.Dot(hoverBoardCast.normalHit, hoverBoardCast.pointHit - b2) + this.hoverIdealHeight > 0f;
					float d = hoverBoardCast.isSolid ? (Vector3.Dot(hoverBoardCast.normalHit, hoverBoardCast.pointHit - this.hoverboardVisual.transform.TransformPoint(hoverBoardCast.localOrigin + hoverBoardCast.localDirection * hoverBoardCast.distance)) + hoverBoardCast.sphereRadius) : (Vector3.Dot(hoverBoardCast.normalHit, hoverBoardCast.pointHit - b) + this.hoverIdealHeight);
					if (flag2)
					{
						flag = true;
						this.boostEnabledUntilTimestamp = Time.time + this.hoverboardBoostGracePeriod;
						if (Vector3.Dot(velocity, hoverBoardCast.normalHit) < 0f)
						{
							velocity = Vector3.ProjectOnPlane(velocity, hoverBoardCast.normalHit);
						}
						this.playerRigidBody.transform.position += hoverBoardCast.normalHit * d;
						Vector3 vector3 = this.turnParent.transform.rotation * (this.hoverboardVisual.IsLeftHanded ? this.leftHand.velocityTracker : this.rightHand.velocityTracker).GetAverageVelocity(false, 0.15f, false);
						if (Vector3.Dot(vector3, hoverBoardCast.normalHit) < 0f)
						{
							velocity -= Vector3.Project(vector3, hoverBoardCast.normalHit) * this.hoverSlamJumpStrengthFactor * Time.fixedDeltaTime;
						}
						a = position + velocity * Time.fixedDeltaTime;
					}
				}
			}
			float time = Mathf.Abs(Mathf.DeltaAngle(0f, Mathf.Acos(Vector3.Dot(this.hoverboardVisual.transform.up, Vector3.ProjectOnPlane(vector2, vector).normalized)) * 57.29578f));
			float num = this.hoverCarveAngleResponsiveness.Evaluate(time);
			vector = (vector + Vector3.ProjectOnPlane(this.hoverboardVisual.transform.up, vector2) * this.hoverTiltAdjustsForwardFactor).normalized;
			if (!flag)
			{
				this.didHoverLastFrame = false;
				num = 0f;
			}
			Vector3 b3 = velocity;
			if (this.enableHoverMode && this.hasHoverPoint)
			{
				Vector3 vector4 = Vector3.ProjectOnPlane(velocity, vector2);
				Vector3 b4 = velocity - vector4;
				Vector3 vector5 = Vector3.Project(vector4, vector);
				float num2 = vector4.magnitude;
				if (num2 <= this.hoveringSlowSpeed)
				{
					num2 *= this.hoveringSlowStoppingFactor;
				}
				Vector3 vector6 = vector4 - vector5;
				float num3 = 0f;
				bool flag3 = false;
				if (num > 0f)
				{
					if (vector6.IsLongerThan(vector5))
					{
						num3 = Mathf.Min((vector6.magnitude - vector5.magnitude) * this.hoverCarveSidewaysSpeedLossFactor * num, num2);
						if (num3 > 0f && num2 > this.hoverMinGrindSpeed)
						{
							flag3 = true;
							this.hoverboardVisual.PlayGrindHaptic();
						}
						num2 -= num3;
					}
					vector6 *= 1f - num * this.sidewaysDrag;
					if (!this.leftHand.isColliding && !this.rightHand.isColliding)
					{
						velocity = (vector5 + vector6).normalized * num2 + b4;
					}
				}
				else
				{
					velocity = vector4.normalized * num2 + b4;
				}
				float magnitude = (velocity - b3).magnitude;
				this.hoverboardAudio.UpdateAudioLoop(velocity.magnitude, this.bodyVelocityTracker.GetAverageVelocity(true, 0.15f, false).magnitude, magnitude, flag3 ? num3 : 0f);
				if (magnitude > 0f && !flag3)
				{
					this.hoverboardVisual.PlayCarveHaptic(magnitude);
				}
			}
			else
			{
				this.hoverboardAudio.UpdateAudioLoop(0f, this.bodyVelocityTracker.GetAverageVelocity(true, 0.15f, false).magnitude, 0f, 0f);
			}
			return velocity;
		}

		// Token: 0x060062EA RID: 25322 RVA: 0x00242450 File Offset: 0x00240650
		public void GrabPersonalHoverboard(bool isLeftHand, Vector3 pos, Quaternion rot, Color col)
		{
			if (this.hoverboardVisual.IsHeld)
			{
				this.hoverboardVisual.DropFreeBoard();
			}
			this.hoverboardVisual.SetIsHeld(isLeftHand, pos, rot, col);
			this.hoverboardVisual.ProxyGrabHandle(isLeftHand);
			FreeHoverboardManager.instance.PreserveMaxHoverboardsConstraint(NetworkSystem.Instance.LocalPlayer.ActorNumber);
		}

		// Token: 0x060062EB RID: 25323 RVA: 0x002424AC File Offset: 0x002406AC
		public void SetHoverAllowed(bool allowed, bool force = false)
		{
			if (allowed)
			{
				this.hoverAllowedCount++;
				this.isHoverAllowed = true;
				return;
			}
			this.hoverAllowedCount = ((force || this.hoverAllowedCount == 0) ? 0 : (this.hoverAllowedCount - 1));
			if (this.hoverAllowedCount == 0 && this.isHoverAllowed)
			{
				this.isHoverAllowed = false;
				if (this.enableHoverMode)
				{
					this.SetHoverActive(false);
					VRRig.LocalRig.hoverboardVisual.SetNotHeld();
				}
			}
		}

		// Token: 0x060062EC RID: 25324 RVA: 0x00242524 File Offset: 0x00240724
		public void SetHoverActive(bool enable)
		{
			if (enable && !this.isHoverAllowed)
			{
				return;
			}
			this.enableHoverMode = enable;
			if (!enable)
			{
				this.bodyCollider.enabled = true;
				this.hasHoverPoint = false;
				this.didHoverLastFrame = false;
				for (int i = 0; i < this.hoverboardCasts.Length; i++)
				{
					this.hoverboardCasts[i].didHit = false;
				}
				this.hoverboardAudio.Stop();
			}
		}

		// Token: 0x060062ED RID: 25325 RVA: 0x00242594 File Offset: 0x00240794
		private void BodyCollider()
		{
			if (this.MaxSphereSizeForNoOverlap(this.bodyInitialRadius * this.scale, this.PositionWithOffset(this.headCollider.transform, this.bodyOffset), false, out this.bodyMaxRadius))
			{
				if (this.scale > 0f)
				{
					this.bodyCollider.radius = this.bodyMaxRadius / this.scale;
				}
				if (Physics.SphereCast(this.PositionWithOffset(this.headCollider.transform, this.bodyOffset), this.bodyMaxRadius, Vector3.down, out this.bodyHitInfo, this.bodyInitialHeight * this.scale - this.bodyMaxRadius, this.locomotionEnabledLayers, QueryTriggerInteraction.Ignore))
				{
					this.bodyCollider.height = (this.bodyHitInfo.distance + this.bodyMaxRadius) / this.scale;
				}
				else
				{
					this.bodyHitInfo = this.emptyHit;
					this.bodyCollider.height = this.bodyInitialHeight;
				}
				if (!this.bodyCollider.gameObject.activeSelf)
				{
					this.bodyCollider.gameObject.SetActive(true);
				}
			}
			else
			{
				this.bodyCollider.gameObject.SetActive(false);
			}
			this.bodyCollider.height = Mathf.Lerp(this.bodyCollider.height, this.bodyInitialHeight, this.bodyLerp);
			this.bodyCollider.radius = Mathf.Lerp(this.bodyCollider.radius, this.bodyInitialRadius, this.bodyLerp);
			this.bodyOffsetVector = Vector3.down * this.bodyCollider.height / 2f;
			this.bodyCollider.transform.position = this.PositionWithOffset(this.headCollider.transform, this.bodyOffset) + this.bodyOffsetVector * this.scale;
			this.bodyCollider.transform.eulerAngles = new Vector3(0f, this.headCollider.transform.eulerAngles.y, 0f);
		}

		// Token: 0x060062EE RID: 25326 RVA: 0x0007CEA2 File Offset: 0x0007B0A2
		private Vector3 PositionWithOffset(Transform transformToModify, Vector3 offsetVector)
		{
			return transformToModify.position + transformToModify.rotation * offsetVector * this.scale;
		}

		// Token: 0x060062EF RID: 25327 RVA: 0x002427A8 File Offset: 0x002409A8
		public void ScaleAwayFromPoint(float oldScale, float newScale, Vector3 scaleCenter)
		{
			if (oldScale < newScale)
			{
				this.lastHeadPosition = GTPlayer.ScalePointAwayFromCenter(this.lastHeadPosition, this.headCollider.radius, oldScale, newScale, scaleCenter);
				this.leftHand.lastPosition = GTPlayer.ScalePointAwayFromCenter(this.leftHand.lastPosition, this.minimumRaycastDistance, oldScale, newScale, scaleCenter);
				this.rightHand.lastPosition = GTPlayer.ScalePointAwayFromCenter(this.rightHand.lastPosition, this.minimumRaycastDistance, oldScale, newScale, scaleCenter);
			}
		}

		// Token: 0x060062F0 RID: 25328 RVA: 0x00242820 File Offset: 0x00240A20
		private static Vector3 ScalePointAwayFromCenter(Vector3 point, float baseRadius, float oldScale, float newScale, Vector3 scaleCenter)
		{
			float magnitude = (point - scaleCenter).magnitude;
			float d = magnitude + Mathf.Epsilon + baseRadius * (newScale - oldScale);
			return scaleCenter + (point - scaleCenter) * d / magnitude;
		}

		// Token: 0x060062F1 RID: 25329 RVA: 0x00242868 File Offset: 0x00240A68
		private void OnBeforeRenderInit()
		{
			if (Application.isPlaying && !this.hasCorrectedForTracking && this.mainCamera != null && this.mainCamera.transform.localPosition != Vector3.zero)
			{
				this.ForceRigidBodySync();
				base.transform.position -= this.mainCamera.transform.localPosition;
				this.hasCorrectedForTracking = true;
			}
			Application.onBeforeRender -= this.OnBeforeRenderInit;
		}

		// Token: 0x060062F2 RID: 25330 RVA: 0x002428F4 File Offset: 0x00240AF4
		private void LateUpdate()
		{
			Vector3 value = this.antiDriftLastPosition.GetValueOrDefault();
			if (this.antiDriftLastPosition == null)
			{
				value = base.transform.position;
				this.antiDriftLastPosition = new Vector3?(value);
			}
			if ((double)(this.antiDriftLastPosition.Value - base.transform.position).sqrMagnitude < 1E-08)
			{
				base.transform.position = this.antiDriftLastPosition.Value;
			}
			else
			{
				this.antiDriftLastPosition = new Vector3?(base.transform.position);
			}
			if (!this.hasCorrectedForTracking && this.mainCamera.transform.localPosition != Vector3.zero)
			{
				base.transform.position -= this.mainCamera.transform.localPosition;
				this.hasCorrectedForTracking = true;
				Application.onBeforeRender -= this.OnBeforeRenderInit;
			}
			if (this.playerRigidBody.isKinematic)
			{
				return;
			}
			float time = Time.time;
			Vector3 position = this.headCollider.transform.position;
			if (this.playerRotationOverrideFrame < Time.frameCount - 1)
			{
				this.playerRotationOverride = Quaternion.Slerp(Quaternion.identity, this.playerRotationOverride, Mathf.Exp(-this.playerRotationOverrideDecayRate * Time.deltaTime));
			}
			base.transform.rotation = this.playerRotationOverride;
			this.turnParent.transform.localScale = VRRig.LocalRig.transform.localScale;
			this.playerRigidBody.MovePosition(this.playerRigidBody.position + position - this.headCollider.transform.position);
			if (Mathf.Abs(this.lastScale - this.scale) > 0.001f)
			{
				if (this.mainCamera == null)
				{
					this.mainCamera = Camera.main;
				}
				this.mainCamera.nearClipPlane = ((this.scale > 0.5f) ? 0.01f : 0.002f);
			}
			this.lastScale = this.scale;
			this.debugLastRightHandPosition = this.rightHand.lastPosition;
			this.debugPlatformDeltaPosition = this.MovingSurfaceMovement();
			if (this.debugMovement)
			{
				this.tempRealTime = Time.time;
				this.calcDeltaTime = Time.deltaTime;
				this.lastRealTime = this.tempRealTime;
			}
			else
			{
				this.tempRealTime = Time.realtimeSinceStartup;
				this.calcDeltaTime = this.tempRealTime - this.lastRealTime;
				this.lastRealTime = this.tempRealTime;
				if (this.calcDeltaTime > 0.1f)
				{
					this.calcDeltaTime = 0.05f;
				}
			}
			Vector3 a;
			if (this.lastFrameHasValidTouchPos && this.lastPlatformTouched != null && GTPlayer.ComputeWorldHitPoint(this.lastHitInfoHand, this.lastFrameTouchPosLocal, out a))
			{
				this.refMovement = a - this.lastFrameTouchPosWorld;
			}
			else
			{
				this.refMovement = Vector3.zero;
			}
			Vector3 vector = Vector3.zero;
			Quaternion quaternion = Quaternion.identity;
			Vector3 pivot = this.headCollider.transform.position;
			Vector3 vector2;
			if (this.lastMovingSurfaceContact != GTPlayer.MovingSurfaceContactPoint.NONE && GTPlayer.ComputeWorldHitPoint(this.lastMovingSurfaceHit, this.lastMovingSurfaceTouchLocal, out vector2))
			{
				if (this.wasMovingSurfaceMonkeBlock && (this.lastMonkeBlock == null || this.lastMonkeBlock.state != BuilderPiece.State.AttachedAndPlaced))
				{
					this.movingSurfaceOffset = Vector3.zero;
				}
				else
				{
					this.movingSurfaceOffset = vector2 - this.lastMovingSurfaceTouchWorld;
					vector = this.movingSurfaceOffset / this.calcDeltaTime;
					quaternion = this.lastMovingSurfaceHit.collider.transform.rotation * Quaternion.Inverse(this.lastMovingSurfaceRot);
					pivot = vector2;
				}
			}
			else
			{
				this.movingSurfaceOffset = Vector3.zero;
			}
			float num = 40f * this.scale;
			if (vector.sqrMagnitude >= num * num)
			{
				this.movingSurfaceOffset = Vector3.zero;
				vector = Vector3.zero;
				quaternion = Quaternion.identity;
			}
			if (!this.didAJump && (this.leftHand.wasColliding || this.rightHand.wasColliding))
			{
				base.transform.position = base.transform.position + 4.9f * Vector3.down * this.calcDeltaTime * this.calcDeltaTime * this.scale;
				if (Vector3.Dot(this.averagedVelocity, this.slideAverageNormal) <= 0f && Vector3.Dot(Vector3.up, this.slideAverageNormal) > 0f)
				{
					base.transform.position = base.transform.position - Vector3.Project(Mathf.Min(this.stickDepth * this.scale, Vector3.Project(this.averagedVelocity, this.slideAverageNormal).magnitude * this.calcDeltaTime) * this.slideAverageNormal, Vector3.down);
				}
			}
			if (!this.didAJump && this.anyHandWasSliding)
			{
				base.transform.position = base.transform.position + this.slideVelocity * this.calcDeltaTime;
				this.slideVelocity += 9.8f * Vector3.down * this.calcDeltaTime * this.scale;
			}
			float paddleBoostFactor = (Time.time > this.boostEnabledUntilTimestamp) ? 0f : (Time.deltaTime * Mathf.Clamp(this.playerRigidBody.linearVelocity.magnitude * this.hoverboardPaddleBoostMultiplier, 0f, this.hoverboardPaddleBoostMax));
			int num2 = 0;
			Vector3 vector3 = Vector3.zero;
			this.anyHandIsColliding = false;
			this.anyHandIsSliding = false;
			this.anyHandIsSticking = false;
			this.leftHand.FirstIteration(ref vector3, ref num2, paddleBoostFactor);
			this.rightHand.FirstIteration(ref vector3, ref num2, paddleBoostFactor);
			for (int i = 0; i < 12; i++)
			{
				if (this.stiltStates[i].isActive)
				{
					this.stiltStates[i].FirstIteration(ref vector3, ref num2, 0f);
				}
			}
			if (num2 != 0)
			{
				vector3 /= (float)num2;
			}
			if (this.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.RIGHT || this.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.LEFT)
			{
				vector3 += this.movingSurfaceOffset;
			}
			else if (this.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.BODY)
			{
				Vector3 b = this.lastHeadPosition + this.movingSurfaceOffset - this.headCollider.transform.position;
				vector3 += b;
			}
			if (!this.MaxSphereSizeForNoOverlap(this.headCollider.radius * 0.9f * this.scale, this.lastHeadPosition, true, out this.maxSphereSize1) && !this.CrazyCheck2(this.headCollider.radius * 0.9f * 0.75f * this.scale, this.lastHeadPosition))
			{
				this.lastHeadPosition = this.lastOpenHeadPosition;
			}
			Vector3 a2;
			float num3;
			if (this.IterativeCollisionSphereCast(this.lastHeadPosition, this.headCollider.radius * 0.9f * this.scale, this.headCollider.transform.position + vector3 - this.lastHeadPosition, Vector3.zero, out a2, false, out num3, out this.junkHit, true))
			{
				vector3 = a2 - this.headCollider.transform.position;
			}
			if (!this.MaxSphereSizeForNoOverlap(this.headCollider.radius * 0.9f * this.scale, this.lastHeadPosition + vector3, true, out this.maxSphereSize1) || !this.CrazyCheck2(this.headCollider.radius * 0.9f * 0.75f * this.scale, this.lastHeadPosition + vector3))
			{
				this.lastHeadPosition = this.lastOpenHeadPosition;
				vector3 = this.lastHeadPosition - this.headCollider.transform.position;
			}
			else if (this.headCollider.radius * 0.9f * 0.825f * this.scale < this.maxSphereSize1)
			{
				this.lastOpenHeadPosition = this.headCollider.transform.position + vector3;
			}
			if (vector3 != Vector3.zero)
			{
				base.transform.position += vector3;
			}
			if (this.lastMovingSurfaceContact != GTPlayer.MovingSurfaceContactPoint.NONE && quaternion != Quaternion.identity && !this.isClimbing && !this.rightHand.isHolding && !this.leftHand.isHolding)
			{
				this.RotateWithSurface(quaternion, pivot);
			}
			this.lastHeadPosition = this.headCollider.transform.position;
			this.areBothTouching = ((!this.leftHand.isColliding && !this.leftHand.wasColliding) || (!this.rightHand.isColliding && !this.rightHand.wasColliding));
			this.HandleHandLink();
			this.HandleTentacleMovement();
			this.anyHandIsColliding = false;
			this.anyHandIsSliding = false;
			this.anyHandIsSticking = false;
			this.leftHand.FinalizeHandPosition();
			this.rightHand.FinalizeHandPosition();
			for (int j = 0; j < 12; j++)
			{
				if (this.stiltStates[j].isActive)
				{
					this.stiltStates[j].FinalizeHandPosition();
					GTPlayer.HandState handState = this.stiltStates[j];
					GorillaTagger.Instance.SetExtraHandPosition((StiltID)j, handState.finalPositionThisFrame, handState.canTag, handState.canStun);
				}
			}
			Vector3 b2 = this.lastPosition;
			GTPlayer.MovingSurfaceContactPoint movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.NONE;
			int num4 = -1;
			int num5 = -1;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = this.rightHand.isColliding && this.IsTouchingMovingSurface(this.rightHand.GetLastPosition(), this.rightHand.lastHitInfo, out num4, out flag, out flag2);
			if (flag4 && !flag)
			{
				movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.RIGHT;
				this.lastMovingSurfaceHit = this.rightHand.lastHitInfo;
			}
			else
			{
				bool flag5 = false;
				BuilderPiece builderPiece = flag4 ? this.lastMonkeBlock : null;
				if (this.leftHand.isColliding && this.IsTouchingMovingSurface(this.leftHand.GetLastPosition(), this.leftHand.lastHitInfo, out num5, out flag5, out flag3))
				{
					if (flag5 && flag2 == flag3)
					{
						if (flag && num5.Equals(num4) && (double)Vector3.Dot(this.leftHand.lastHitInfo.point - this.leftHand.GetLastPosition(), this.rightHand.lastHitInfo.point - this.rightHand.GetLastPosition()) < 0.3)
						{
							movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.RIGHT;
							this.lastMovingSurfaceHit = this.rightHand.lastHitInfo;
							this.lastMonkeBlock = builderPiece;
						}
					}
					else
					{
						movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.LEFT;
						this.lastMovingSurfaceHit = this.leftHand.lastHitInfo;
					}
				}
			}
			this.StoreVelocities();
			if (this.InWater)
			{
				PlayerGameEvents.PlayerSwam((this.lastPosition - b2).magnitude, this.currentVelocity.magnitude);
			}
			else
			{
				PlayerGameEvents.PlayerMoved((this.lastPosition - b2).magnitude, this.currentVelocity.magnitude);
			}
			this.didAJump = false;
			bool flag6 = this.exitMovingSurface;
			this.exitMovingSurface = false;
			if (this.leftHand.IsSlipOverriddenToMax() && this.rightHand.IsSlipOverriddenToMax())
			{
				this.didAJump = true;
				this.exitMovingSurface = true;
			}
			else if (this.anyHandIsSliding)
			{
				this.slideAverageNormal = Vector3.zero;
				int num6 = 0;
				this.averageSlipPercentage = 0f;
				bool flag7 = false;
				if (this.leftHand.isSliding)
				{
					this.slideAverageNormal += this.leftHand.slideNormal.normalized;
					this.averageSlipPercentage += this.leftHand.slipPercentage;
					num6++;
				}
				if (this.rightHand.isSliding)
				{
					flag7 = true;
					this.slideAverageNormal += this.rightHand.slideNormal.normalized;
					this.averageSlipPercentage += this.rightHand.slipPercentage;
					num6++;
				}
				for (int k = 0; k < this.stiltStates.Length; k++)
				{
					if (this.stiltStates[k].isActive && this.stiltStates[k].isSliding)
					{
						if (!this.stiltStates[k].isLeftHand)
						{
							flag7 = true;
						}
						this.slideAverageNormal += this.stiltStates[k].slideNormal.normalized;
						this.averageSlipPercentage += this.stiltStates[k].slipPercentage;
						num6++;
					}
				}
				this.slideAverageNormal = this.slideAverageNormal.normalized;
				this.averageSlipPercentage /= (float)num6;
				if (num6 == 1)
				{
					this.surfaceDirection = (flag7 ? Vector3.ProjectOnPlane(this.rightHand.handFollower.forward, this.rightHand.slideNormal) : Vector3.ProjectOnPlane(this.leftHand.handFollower.forward, this.leftHand.slideNormal));
					if (Vector3.Dot(this.slideVelocity, this.surfaceDirection) > 0f)
					{
						this.slideVelocity = Vector3.Project(this.slideVelocity, Vector3.Slerp(this.slideVelocity, this.surfaceDirection.normalized * this.slideVelocity.magnitude, this.slideControl));
					}
					else
					{
						this.slideVelocity = Vector3.Project(this.slideVelocity, Vector3.Slerp(this.slideVelocity, -this.surfaceDirection.normalized * this.slideVelocity.magnitude, this.slideControl));
					}
				}
				if (!this.anyHandWasSliding)
				{
					this.slideVelocity = ((Vector3.Dot(this.playerRigidBody.linearVelocity, this.slideAverageNormal) <= 0f) ? Vector3.ProjectOnPlane(this.playerRigidBody.linearVelocity, this.slideAverageNormal) : this.playerRigidBody.linearVelocity);
				}
				else
				{
					this.slideVelocity = ((Vector3.Dot(this.slideVelocity, this.slideAverageNormal) <= 0f) ? Vector3.ProjectOnPlane(this.slideVelocity, this.slideAverageNormal) : this.slideVelocity);
				}
				this.slideVelocity = this.slideVelocity.normalized * Mathf.Min(this.slideVelocity.magnitude, Mathf.Max(0.5f, this.averagedVelocity.magnitude * 2f));
				this.playerRigidBody.linearVelocity = Vector3.zero;
			}
			else if (this.anyHandIsColliding)
			{
				if (!this.turnedThisFrame)
				{
					this.playerRigidBody.linearVelocity = Vector3.zero;
				}
				else
				{
					this.playerRigidBody.linearVelocity = this.playerRigidBody.linearVelocity.normalized * Mathf.Min(2f, this.playerRigidBody.linearVelocity.magnitude);
				}
			}
			else if (this.anyHandWasSliding)
			{
				this.playerRigidBody.linearVelocity = ((Vector3.Dot(this.slideVelocity, this.slideAverageNormal) <= 0f) ? Vector3.ProjectOnPlane(this.slideVelocity, this.slideAverageNormal) : this.slideVelocity);
			}
			if (this.anyHandIsColliding && !this.disableMovement && !this.turnedThisFrame && !this.didAJump)
			{
				if (this.anyHandIsSliding)
				{
					if (Vector3.Project(this.averagedVelocity, this.slideAverageNormal).magnitude > this.slideVelocityLimit * this.scale && Vector3.Dot(this.averagedVelocity, this.slideAverageNormal) > 0f && Vector3.Project(this.averagedVelocity, this.slideAverageNormal).magnitude > Vector3.Project(this.slideVelocity, this.slideAverageNormal).magnitude)
					{
						this.leftHand.isSliding = false;
						this.rightHand.isSliding = false;
						for (int l = 0; l < this.stiltStates.Length; l++)
						{
							this.stiltStates[l].isSliding = false;
						}
						this.anyHandIsSliding = false;
						this.didAJump = true;
						float num7 = this.ApplyNativeScaleAdjustment(Mathf.Min(this.maxJumpSpeed * this.ExtraVelMaxMultiplier(), this.jumpMultiplier * this.ExtraVelMultiplier() * Vector3.Project(this.averagedVelocity, this.slideAverageNormal).magnitude));
						this.playerRigidBody.linearVelocity = num7 * this.slideAverageNormal.normalized + Vector3.ProjectOnPlane(this.slideVelocity, this.slideAverageNormal);
						if (num7 > this.slideVelocityLimit * this.scale * this.exitMovingSurfaceThreshold)
						{
							this.exitMovingSurface = true;
						}
					}
				}
				else if (this.averagedVelocity.magnitude > this.velocityLimit * this.scale)
				{
					float num8 = (this.InWater && this.CurrentWaterVolume != null) ? this.liquidPropertiesList[(int)this.CurrentWaterVolume.LiquidType].surfaceJumpFactor : 1f;
					float num9 = this.ApplyNativeScaleAdjustment(this.enableHoverMode ? Mathf.Min(this.hoverMaxPaddleSpeed, this.averagedVelocity.magnitude) : Mathf.Min(this.maxJumpSpeed * this.ExtraVelMaxMultiplier(), this.jumpMultiplier * this.ExtraVelMultiplier() * num8 * this.averagedVelocity.magnitude));
					Vector3 vector4 = num9 * this.averagedVelocity.normalized;
					this.didAJump = true;
					this.playerRigidBody.linearVelocity = vector4;
					if (this.InWater)
					{
						this.swimmingVelocity += vector4 * this.swimmingParams.underwaterJumpsAsSwimVelocityFactor;
					}
					if (num9 > this.velocityLimit * this.scale * this.exitMovingSurfaceThreshold)
					{
						this.exitMovingSurface = true;
					}
				}
			}
			this.stuckHandsCheckLateUpdate(ref this.leftHand.finalPositionThisFrame, ref this.rightHand.finalPositionThisFrame);
			if (this.lastPlatformTouched != null && this.currentPlatform == null)
			{
				if (!this.playerRigidBody.isKinematic)
				{
					this.playerRigidBody.linearVelocity += this.refMovement / this.calcDeltaTime;
				}
				this.refMovement = Vector3.zero;
			}
			if (this.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.NONE)
			{
				if (!this.playerRigidBody.isKinematic)
				{
					this.playerRigidBody.linearVelocity += this.lastMovingSurfaceVelocity;
				}
				this.lastMovingSurfaceVelocity = Vector3.zero;
			}
			if (this.enableHoverMode)
			{
				this.HoverboardLateUpdate();
			}
			else
			{
				this.hasHoverPoint = false;
			}
			Vector3 vector5 = Vector3.zero;
			float a3 = 0f;
			float a4 = 0f;
			if (this.bodyInWater)
			{
				Vector3 b3;
				if (this.GetSwimmingVelocityForHand(this.leftHand.lastPosition, this.leftHand.finalPositionThisFrame, this.leftHand.controllerTransform.right, this.calcDeltaTime, ref this.leftHandWaterVolume, ref this.leftHandWaterSurface, out b3) && !this.turnedThisFrame)
				{
					a3 = Mathf.InverseLerp(0f, 0.2f, b3.magnitude) * this.swimmingParams.swimmingHapticsStrength;
					vector5 += b3;
				}
				Vector3 b4;
				if (this.GetSwimmingVelocityForHand(this.rightHand.lastPosition, this.rightHand.finalPositionThisFrame, -this.rightHand.controllerTransform.right, this.calcDeltaTime, ref this.rightHandWaterVolume, ref this.rightHandWaterSurface, out b4) && !this.turnedThisFrame)
				{
					a4 = Mathf.InverseLerp(0f, 0.15f, b4.magnitude) * this.swimmingParams.swimmingHapticsStrength;
					vector5 += b4;
				}
			}
			Vector3 vector6 = Vector3.zero;
			Vector3 b5;
			if (this.swimmingParams.allowWaterSurfaceJumps && time - this.lastWaterSurfaceJumpTimeLeft > this.waterSurfaceJumpCooldown && this.CheckWaterSurfaceJump(this.leftHand.lastPosition, this.leftHand.finalPositionThisFrame, this.leftHand.controllerTransform.right, this.leftHand.velocityTracker.GetAverageVelocity(false, 0.1f, false) * this.scale, this.swimmingParams, this.leftHandWaterVolume, this.leftHandWaterSurface, out b5))
			{
				if (time - this.lastWaterSurfaceJumpTimeRight > this.waterSurfaceJumpCooldown)
				{
					vector6 += b5;
				}
				this.lastWaterSurfaceJumpTimeLeft = Time.time;
				GorillaTagger.Instance.StartVibration(true, GorillaTagger.Instance.tapHapticStrength, GorillaTagger.Instance.tapHapticDuration);
			}
			Vector3 b6;
			if (this.swimmingParams.allowWaterSurfaceJumps && time - this.lastWaterSurfaceJumpTimeRight > this.waterSurfaceJumpCooldown && this.CheckWaterSurfaceJump(this.rightHand.lastPosition, this.rightHand.finalPositionThisFrame, -this.rightHand.controllerTransform.right, this.rightHand.velocityTracker.GetAverageVelocity(false, 0.1f, false) * this.scale, this.swimmingParams, this.rightHandWaterVolume, this.rightHandWaterSurface, out b6))
			{
				if (time - this.lastWaterSurfaceJumpTimeLeft > this.waterSurfaceJumpCooldown)
				{
					vector6 += b6;
				}
				this.lastWaterSurfaceJumpTimeRight = Time.time;
				GorillaTagger.Instance.StartVibration(false, GorillaTagger.Instance.tapHapticStrength, GorillaTagger.Instance.tapHapticDuration);
			}
			vector6 = Vector3.ClampMagnitude(vector6, this.swimmingParams.waterSurfaceJumpMaxSpeed * this.scale);
			float num10 = Mathf.Max(a3, this.leftHandNonDiveHapticsAmount);
			if (num10 > 0.001f && time - this.lastWaterSurfaceJumpTimeLeft > GorillaTagger.Instance.tapHapticDuration)
			{
				GorillaTagger.Instance.DoVibration(XRNode.LeftHand, num10, this.calcDeltaTime);
			}
			float num11 = Mathf.Max(a4, this.rightHandNonDiveHapticsAmount);
			if (num11 > 0.001f && time - this.lastWaterSurfaceJumpTimeRight > GorillaTagger.Instance.tapHapticDuration)
			{
				GorillaTagger.Instance.DoVibration(XRNode.RightHand, num11, this.calcDeltaTime);
			}
			if (!this.disableMovement)
			{
				this.swimmingVelocity += vector5;
				if (!this.playerRigidBody.isKinematic)
				{
					this.playerRigidBody.linearVelocity += vector5 + vector6;
				}
			}
			else
			{
				this.swimmingVelocity = Vector3.zero;
			}
			if (GorillaGameManager.instance is GorillaFreezeTagManager)
			{
				if (!this.IsFrozen || !this.primaryButtonPressed)
				{
					this.IsBodySliding = false;
					this.lastSlopeDirection = Vector3.zero;
					if (this.bodyTouchedSurfaces.Count > 0)
					{
						foreach (KeyValuePair<GameObject, PhysicsMaterial> keyValuePair in this.bodyTouchedSurfaces)
						{
							MeshCollider meshCollider;
							if (keyValuePair.Key.TryGetComponent<MeshCollider>(out meshCollider))
							{
								meshCollider.material = keyValuePair.Value;
							}
						}
						this.bodyTouchedSurfaces.Clear();
					}
				}
				else if (this.BodyOnGround && this.primaryButtonPressed)
				{
					float y = this.bodyInitialHeight / 2f - this.bodyInitialRadius;
					RaycastHit raycastHit;
					if (Physics.SphereCast(this.bodyCollider.transform.position - new Vector3(0f, y, 0f), this.bodyInitialRadius - 0.01f, Vector3.down, out raycastHit, 1f, ~LayerMask.GetMask(new string[]
					{
						"Gorilla Body Collider",
						"GorillaInteractable"
					}), QueryTriggerInteraction.Ignore))
					{
						this.IsBodySliding = true;
						MeshCollider meshCollider2;
						if (!this.bodyTouchedSurfaces.ContainsKey(raycastHit.transform.gameObject) && raycastHit.transform.gameObject.TryGetComponent<MeshCollider>(out meshCollider2))
						{
							this.bodyTouchedSurfaces.Add(raycastHit.transform.gameObject, meshCollider2.material);
							raycastHit.transform.gameObject.GetComponent<MeshCollider>().material = this.slipperyMaterial;
						}
					}
				}
				else
				{
					this.IsBodySliding = false;
					this.lastSlopeDirection = Vector3.zero;
				}
			}
			else
			{
				this.IsBodySliding = false;
				if (this.bodyTouchedSurfaces.Count > 0)
				{
					foreach (KeyValuePair<GameObject, PhysicsMaterial> keyValuePair2 in this.bodyTouchedSurfaces)
					{
						MeshCollider meshCollider3;
						if (keyValuePair2.Key.TryGetComponent<MeshCollider>(out meshCollider3))
						{
							meshCollider3.material = keyValuePair2.Value;
						}
					}
					this.bodyTouchedSurfaces.Clear();
				}
			}
			this.leftHand.OnEndOfFrame();
			this.rightHand.OnEndOfFrame();
			for (int m = 0; m < 12; m++)
			{
				if (this.stiltStates[m].isActive)
				{
					this.stiltStates[m].OnEndOfFrame();
				}
			}
			this.leftHand.PositionHandFollower();
			this.rightHand.PositionHandFollower();
			this.anyHandWasSliding = this.anyHandIsSliding;
			this.anyHandWasColliding = this.anyHandIsColliding;
			this.anyHandWasSticking = this.anyHandIsSticking;
			if (this.anyHandIsSticking)
			{
				this.lastTouchedGroundTimestamp = Time.time;
			}
			if (PhotonNetwork.InRoom)
			{
				if (this.IsGroundedHand || this.IsThrusterActive)
				{
					this.LastHandTouchedGroundAtNetworkTime = (float)PhotonNetwork.Time;
					this.LastTouchedGroundAtNetworkTime = (float)PhotonNetwork.Time;
				}
				else if (this.IsGroundedButt)
				{
					this.LastTouchedGroundAtNetworkTime = (float)PhotonNetwork.Time;
				}
			}
			else
			{
				this.LastHandTouchedGroundAtNetworkTime = 0f;
				this.LastTouchedGroundAtNetworkTime = 0f;
			}
			this.degreesTurnedThisFrame = 0f;
			this.lastPlatformTouched = this.currentPlatform;
			this.currentPlatform = null;
			this.lastMovingSurfaceVelocity = vector;
			Vector3 vector7;
			if (GTPlayer.ComputeLocalHitPoint(this.lastHitInfoHand, out vector7))
			{
				this.lastFrameHasValidTouchPos = true;
				this.lastFrameTouchPosLocal = vector7;
				this.lastFrameTouchPosWorld = this.lastHitInfoHand.point;
			}
			else
			{
				this.lastFrameHasValidTouchPos = false;
				this.lastFrameTouchPosLocal = Vector3.zero;
				this.lastFrameTouchPosWorld = Vector3.zero;
			}
			this.lastRigidbodyPosition = this.playerRigidBody.transform.position;
			RaycastHit raycastHit2 = this.emptyHit;
			this.BodyCollider();
			if (this.bodyHitInfo.collider != null)
			{
				this.wasBodyOnGround = true;
				raycastHit2 = this.bodyHitInfo;
			}
			else if (movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.NONE && this.bodyCollider.gameObject.activeSelf)
			{
				bool flag8 = false;
				this.ClearRaycasthitBuffer(ref this.rayCastNonAllocColliders);
				Vector3 origin = this.PositionWithOffset(this.headCollider.transform, this.bodyOffset) + (this.bodyInitialHeight * this.scale - this.bodyMaxRadius) * Vector3.down;
				this.bufferCount = Physics.SphereCastNonAlloc(origin, this.bodyMaxRadius, Vector3.down, this.rayCastNonAllocColliders, this.minimumRaycastDistance * this.scale, this.locomotionEnabledLayers.value);
				if (this.bufferCount > 0)
				{
					this.tempHitInfo = this.rayCastNonAllocColliders[0];
					for (int n = 0; n < this.bufferCount; n++)
					{
						if (this.tempHitInfo.distance > 0f && (!flag8 || this.rayCastNonAllocColliders[n].distance < this.tempHitInfo.distance))
						{
							flag8 = true;
							raycastHit2 = this.rayCastNonAllocColliders[n];
						}
					}
				}
				this.wasBodyOnGround = flag8;
			}
			int num12 = -1;
			bool flag9 = false;
			bool flag10;
			if (this.wasBodyOnGround && movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.NONE && this.IsTouchingMovingSurface(this.PositionWithOffset(this.headCollider.transform, this.bodyOffset), raycastHit2, out num12, out flag10, out flag9) && !flag10)
			{
				movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.BODY;
				this.lastMovingSurfaceHit = raycastHit2;
			}
			Vector3 vector8;
			if (movingSurfaceContactPoint != GTPlayer.MovingSurfaceContactPoint.NONE && GTPlayer.ComputeLocalHitPoint(this.lastMovingSurfaceHit, out vector8))
			{
				this.lastMovingSurfaceTouchLocal = vector8;
				this.lastMovingSurfaceTouchWorld = this.lastMovingSurfaceHit.point;
				this.lastMovingSurfaceRot = this.lastMovingSurfaceHit.collider.transform.rotation;
				this.lastAttachedToMovingSurfaceFrame = Time.frameCount;
			}
			else
			{
				movingSurfaceContactPoint = GTPlayer.MovingSurfaceContactPoint.NONE;
				this.lastMovingSurfaceTouchLocal = Vector3.zero;
				this.lastMovingSurfaceTouchWorld = Vector3.zero;
				this.lastMovingSurfaceRot = Quaternion.identity;
			}
			Vector3 position2 = this.lastMovingSurfaceTouchWorld;
			int num13 = -1;
			bool flag11 = false;
			switch (movingSurfaceContactPoint)
			{
			case GTPlayer.MovingSurfaceContactPoint.NONE:
				if (flag6)
				{
					this.exitMovingSurface = true;
				}
				num13 = -1;
				break;
			case GTPlayer.MovingSurfaceContactPoint.RIGHT:
				num13 = num4;
				flag11 = flag2;
				position2 = GorillaTagger.Instance.offlineVRRig.rightHandTransform.position;
				break;
			case GTPlayer.MovingSurfaceContactPoint.LEFT:
				num13 = num5;
				flag11 = flag3;
				position2 = GorillaTagger.Instance.offlineVRRig.leftHandTransform.position;
				break;
			case GTPlayer.MovingSurfaceContactPoint.BODY:
				num13 = num12;
				flag11 = flag9;
				position2 = GorillaTagger.Instance.offlineVRRig.bodyTransform.position;
				break;
			}
			if (!flag11)
			{
				this.lastMonkeBlock = null;
			}
			if (num13 != this.lastMovingSurfaceID || this.lastMovingSurfaceContact != movingSurfaceContactPoint || flag11 != this.wasMovingSurfaceMonkeBlock)
			{
				if (num13 == -1)
				{
					if (Time.frameCount - this.lastAttachedToMovingSurfaceFrame > 3)
					{
						VRRig.DetachLocalPlayerFromMovingSurface();
						this.lastMovingSurfaceID = -1;
					}
				}
				else if (flag11)
				{
					if (this.lastMonkeBlock != null)
					{
						VRRig.AttachLocalPlayerToMovingSurface(num13, movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.LEFT, movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.BODY, this.lastMonkeBlock.transform.InverseTransformPoint(position2), flag11);
						this.lastMovingSurfaceID = num13;
					}
					else
					{
						VRRig.DetachLocalPlayerFromMovingSurface();
						this.lastMovingSurfaceID = -1;
					}
				}
				else if (MovingSurfaceManager.instance != null)
				{
					MovingSurface movingSurface;
					if (MovingSurfaceManager.instance.TryGetMovingSurface(num13, out movingSurface))
					{
						VRRig.AttachLocalPlayerToMovingSurface(num13, movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.LEFT, movingSurfaceContactPoint == GTPlayer.MovingSurfaceContactPoint.BODY, movingSurface.transform.InverseTransformPoint(position2), flag11);
						this.lastMovingSurfaceID = num13;
					}
					else
					{
						VRRig.DetachLocalPlayerFromMovingSurface();
						this.lastMovingSurfaceID = -1;
					}
				}
				else
				{
					VRRig.DetachLocalPlayerFromMovingSurface();
					this.lastMovingSurfaceID = -1;
				}
			}
			if (this.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.NONE && movingSurfaceContactPoint != GTPlayer.MovingSurfaceContactPoint.NONE)
			{
				this.SetPlayerVelocity(Vector3.zero);
			}
			this.lastMovingSurfaceContact = movingSurfaceContactPoint;
			this.wasMovingSurfaceMonkeBlock = flag11;
			if (this.activeSizeChangerSettings != null)
			{
				if (this.activeSizeChangerSettings.ExpireOnDistance > 0f && Vector3.Distance(base.transform.position, this.activeSizeChangerSettings.WorldPosition) > this.activeSizeChangerSettings.ExpireOnDistance)
				{
					this.SetNativeScale(null);
				}
				if (this.activeSizeChangerSettings.ExpireAfterSeconds > 0f && Time.time - this.activeSizeChangerSettings.ActivationTime > this.activeSizeChangerSettings.ExpireAfterSeconds)
				{
					this.SetNativeScale(null);
				}
			}
			HandLink grabbedLink = VRRig.LocalRig.leftHandLink.grabbedLink;
			if (grabbedLink != null)
			{
				double time2 = PhotonNetwork.Time;
				float lastHandTouchedGroundAtNetworkTime = this.LastHandTouchedGroundAtNetworkTime;
				double time3 = PhotonNetwork.Time;
				float lastHandTouchedGroundAtNetworkTime2 = grabbedLink.myRig.LastHandTouchedGroundAtNetworkTime;
			}
			if (this.didAJump || this.anyHandIsColliding || this.anyHandIsSliding || this.anyHandIsSticking || this.IsGroundedHand || this.forceRBSync)
			{
				this.forceRBSync = false;
			}
		}

		// Token: 0x060062F3 RID: 25331 RVA: 0x0007CEC6 File Offset: 0x0007B0C6
		private float ApplyNativeScaleAdjustment(float adjustedMagnitude)
		{
			if (this.nativeScale > 0f && this.nativeScale != 1f)
			{
				return adjustedMagnitude *= this.nativeScaleMagnitudeAdjustmentFactor.Evaluate(this.nativeScale);
			}
			return adjustedMagnitude;
		}

		// Token: 0x060062F4 RID: 25332 RVA: 0x00244864 File Offset: 0x00242A64
		private float RotateWithSurface(Quaternion rotationDelta, Vector3 pivot)
		{
			Quaternion quaternion;
			Quaternion quaternion2;
			QuaternionUtil.DecomposeSwingTwist(rotationDelta, Vector3.up, out quaternion, out quaternion2);
			float num = quaternion2.eulerAngles.y;
			if (num > 270f)
			{
				num -= 360f;
			}
			else if (num > 90f)
			{
				num -= 180f;
			}
			if (Mathf.Abs(num) < 90f * this.calcDeltaTime)
			{
				this.turnParent.transform.RotateAround(pivot, base.transform.up, num);
				return num;
			}
			return 0f;
		}

		// Token: 0x060062F5 RID: 25333 RVA: 0x002448E8 File Offset: 0x00242AE8
		private void stuckHandsCheckFixedUpdate()
		{
			Vector3 currentHandPosition = this.leftHand.GetCurrentHandPosition();
			this.stuckLeft = (!this.controllerState.LeftValid || (this.leftHand.isColliding && (currentHandPosition - this.leftHand.GetLastPosition()).magnitude > this.unStickDistance * this.scale && !Physics.Raycast(this.headCollider.transform.position, (currentHandPosition - this.headCollider.transform.position).normalized, (currentHandPosition - this.headCollider.transform.position).magnitude, this.locomotionEnabledLayers.value)));
			Vector3 currentHandPosition2 = this.rightHand.GetCurrentHandPosition();
			this.stuckRight = (!this.controllerState.RightValid || (this.rightHand.isColliding && (currentHandPosition2 - this.rightHand.GetLastPosition()).magnitude > this.unStickDistance * this.scale && !Physics.Raycast(this.headCollider.transform.position, (currentHandPosition2 - this.headCollider.transform.position).normalized, (currentHandPosition2 - this.headCollider.transform.position).magnitude, this.locomotionEnabledLayers.value)));
		}

		// Token: 0x060062F6 RID: 25334 RVA: 0x00244A74 File Offset: 0x00242C74
		private void stuckHandsCheckLateUpdate(ref Vector3 finalLeftHandPosition, ref Vector3 finalRightHandPosition)
		{
			if (this.stuckLeft)
			{
				finalLeftHandPosition = this.leftHand.GetCurrentHandPosition();
				this.stuckLeft = (this.leftHand.isColliding = false);
			}
			if (this.stuckRight)
			{
				finalRightHandPosition = this.rightHand.GetCurrentHandPosition();
				this.stuckRight = (this.rightHand.isColliding = false);
			}
		}

		// Token: 0x060062F7 RID: 25335 RVA: 0x00244AE0 File Offset: 0x00242CE0
		private void handleClimbing(float deltaTime)
		{
			if (this.isClimbing && (this.inOverlay || this.climbHelper == null || this.currentClimbable == null || !this.currentClimbable.isActiveAndEnabled))
			{
				this.EndClimbing(this.currentClimber, false, false);
			}
			Vector3 vector = Vector3.zero;
			if (this.isClimbing && (this.currentClimber.transform.position - this.climbHelper.position).magnitude > 1f)
			{
				this.EndClimbing(this.currentClimber, false, false);
			}
			if (this.isClimbing)
			{
				this.playerRigidBody.linearVelocity = Vector3.zero;
				this.climbHelper.localPosition = Vector3.MoveTowards(this.climbHelper.localPosition, this.climbHelperTargetPos, deltaTime * 12f);
				vector = this.currentClimber.transform.position - this.climbHelper.position;
				vector = ((vector.sqrMagnitude > this.maxArmLength * this.maxArmLength) ? (vector.normalized * this.maxArmLength) : vector);
				if (this.isClimbableMoving)
				{
					Quaternion rotationDelta = this.currentClimbable.transform.rotation * Quaternion.Inverse(this.lastClimbableRotation);
					this.RotateWithSurface(rotationDelta, this.currentClimber.handRoot.position);
					this.lastClimbableRotation = this.currentClimbable.transform.rotation;
				}
				this.playerRigidBody.MovePosition(this.playerRigidBody.position - vector);
				if (this.currentSwing)
				{
					this.currentSwing.lastGrabTime = Time.time;
				}
			}
		}

		// Token: 0x060062F8 RID: 25336 RVA: 0x0007CEFA File Offset: 0x0007B0FA
		public void RequestTentacleMove(bool isLeftHand, Vector3 move)
		{
			if (isLeftHand)
			{
				this.hasLeftHandTentacleMove = true;
				this.leftHandTentacleMove = move;
				return;
			}
			this.hasRightHandTentacleMove = true;
			this.rightHandTentacleMove = move;
		}

		// Token: 0x060062F9 RID: 25337 RVA: 0x00244CA0 File Offset: 0x00242EA0
		public void HandleTentacleMovement()
		{
			Vector3 b;
			if (this.hasLeftHandTentacleMove)
			{
				if (this.hasRightHandTentacleMove)
				{
					b = (this.leftHandTentacleMove + this.rightHandTentacleMove) * 0.5f;
					this.hasRightHandTentacleMove = (this.hasLeftHandTentacleMove = false);
				}
				else
				{
					b = this.leftHandTentacleMove;
					this.hasLeftHandTentacleMove = false;
				}
			}
			else
			{
				if (!this.hasRightHandTentacleMove)
				{
					return;
				}
				b = this.rightHandTentacleMove;
				this.hasRightHandTentacleMove = false;
			}
			this.playerRigidBody.transform.position += b;
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x060062FA RID: 25338 RVA: 0x00244D40 File Offset: 0x00242F40
		public HandLinkAuthorityStatus GetSelfHandLinkAuthority()
		{
			int actorNumber = PhotonNetwork.LocalPlayer.ActorNumber;
			if (this.IsGroundedHand)
			{
				return new HandLinkAuthorityStatus(HandLinkAuthorityType.HandGrounded);
			}
			if ((double)(this.LastHandTouchedGroundAtNetworkTime + 1f) > PhotonNetwork.Time)
			{
				return new HandLinkAuthorityStatus(HandLinkAuthorityType.ResidualHandGrounded, this.LastHandTouchedGroundAtNetworkTime, actorNumber);
			}
			if (this.IsGroundedButt)
			{
				return new HandLinkAuthorityStatus(HandLinkAuthorityType.ButtGrounded);
			}
			return new HandLinkAuthorityStatus(HandLinkAuthorityType.None, this.LastTouchedGroundAtNetworkTime, actorNumber);
		}

		// Token: 0x060062FB RID: 25339 RVA: 0x00244DA8 File Offset: 0x00242FA8
		private void HandleHandLink()
		{
			HandLink leftHandLink = VRRig.LocalRig.leftHandLink;
			HandLink rightHandLink = VRRig.LocalRig.rightHandLink;
			bool flag = leftHandLink.grabbedLink != null;
			bool flag2 = rightHandLink.grabbedLink != null;
			if (!flag && !flag2)
			{
				return;
			}
			HandLinkAuthorityStatus selfHandLinkAuthority = this.GetSelfHandLinkAuthority();
			int num = -1;
			HandLinkAuthorityStatus chainAuthority = new HandLinkAuthorityStatus(HandLinkAuthorityType.None);
			if (flag)
			{
				chainAuthority = leftHandLink.GetChainAuthority(out num);
			}
			int num2 = -1;
			HandLinkAuthorityStatus chainAuthority2 = new HandLinkAuthorityStatus(HandLinkAuthorityType.None);
			if (flag2)
			{
				chainAuthority2 = rightHandLink.GetChainAuthority(out num2);
			}
			if (flag && flag2)
			{
				if (leftHandLink.grabbedPlayer == rightHandLink.grabbedPlayer)
				{
					switch (selfHandLinkAuthority.CompareTo(chainAuthority))
					{
					case -1:
						this.HandLink_PositionChild_LocalPlayer(leftHandLink, rightHandLink);
						return;
					case 0:
						this.HandLink_PositionBoth_BothHands(leftHandLink, rightHandLink);
						return;
					case 1:
						this.HandLink_PositionChild_RemotePlayer_BothHands(leftHandLink, rightHandLink);
						return;
					default:
						return;
					}
				}
				else
				{
					int num3 = selfHandLinkAuthority.CompareTo(chainAuthority);
					int num4 = selfHandLinkAuthority.CompareTo(chainAuthority2);
					switch (num3 * 3 + num4)
					{
					case -3:
					case -2:
						this.HandLink_PositionChild_LocalPlayer(leftHandLink);
						this.HandLink_PositionChild_RemotePlayer(rightHandLink);
						return;
					case -1:
					case 2:
						this.HandLink_PositionChild_LocalPlayer(rightHandLink);
						this.HandLink_PositionChild_RemotePlayer(leftHandLink);
						return;
					case 0:
						this.HandLink_PositionTriple(leftHandLink, rightHandLink);
						return;
					case 1:
						this.HandLink_PositionBoth(leftHandLink);
						this.HandLink_PositionChild_RemotePlayer(rightHandLink);
						return;
					case 3:
						this.HandLink_PositionBoth(rightHandLink);
						this.HandLink_PositionChild_RemotePlayer(leftHandLink);
						return;
					case 4:
						this.HandLink_PositionChild_RemotePlayer(leftHandLink);
						this.HandLink_PositionChild_RemotePlayer(rightHandLink);
						return;
					}
					switch (chainAuthority.CompareTo(chainAuthority2))
					{
					case -1:
						this.HandLink_PositionChild_LocalPlayer(rightHandLink);
						this.HandLink_PositionChild_RemotePlayer(leftHandLink);
						return;
					case 0:
						if (num > num2)
						{
							this.HandLink_PositionChild_LocalPlayer(rightHandLink);
							this.HandLink_PositionChild_RemotePlayer(leftHandLink);
							return;
						}
						if (num < num2)
						{
							this.HandLink_PositionChild_LocalPlayer(leftHandLink);
							this.HandLink_PositionChild_RemotePlayer(rightHandLink);
							return;
						}
						this.HandLink_PositionChild_LocalPlayer(leftHandLink, rightHandLink);
						return;
					case 1:
						this.HandLink_PositionChild_LocalPlayer(leftHandLink);
						this.HandLink_PositionChild_RemotePlayer(rightHandLink);
						return;
					default:
						return;
					}
				}
			}
			else if (flag)
			{
				switch (selfHandLinkAuthority.CompareTo(chainAuthority))
				{
				case -1:
					this.HandLink_PositionChild_LocalPlayer(leftHandLink);
					return;
				case 0:
					this.HandLink_PositionBoth(leftHandLink);
					return;
				case 1:
					this.HandLink_PositionChild_RemotePlayer(leftHandLink);
					return;
				default:
					return;
				}
			}
			else
			{
				switch (selfHandLinkAuthority.CompareTo(chainAuthority2))
				{
				case -1:
					this.HandLink_PositionChild_LocalPlayer(rightHandLink);
					return;
				case 0:
					this.HandLink_PositionBoth(rightHandLink);
					return;
				case 1:
					this.HandLink_PositionChild_RemotePlayer(rightHandLink);
					return;
				default:
					return;
				}
			}
		}

		// Token: 0x060062FC RID: 25340 RVA: 0x00244FFC File Offset: 0x002431FC
		private void HandLink_PositionTriple(HandLink linkA, HandLink linkB)
		{
			Vector3 a = linkA.transform.position - linkA.grabbedLink.transform.position;
			Vector3 vector = linkB.transform.position - linkB.grabbedLink.transform.position;
			Vector3 b = (a + vector) * 0.33f;
			bool flag;
			bool flag2;
			linkA.grabbedLink.myRig.TrySweptOffsetMove(a - b, out flag, out flag2);
			bool flag3;
			bool flag4;
			linkB.grabbedLink.myRig.TrySweptOffsetMove(vector - b, out flag3, out flag4);
			this.playerRigidBody.MovePosition(this.playerRigidBody.position - b);
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x060062FD RID: 25341 RVA: 0x002450C0 File Offset: 0x002432C0
		private void HandLink_PositionBoth(HandLink link)
		{
			Vector3 vector = (link.grabbedLink.transform.position - link.transform.position) * 0.5f;
			bool flag;
			bool flag2;
			link.grabbedLink.myRig.TrySweptOffsetMove(-vector, out flag, out flag2);
			if (flag || flag2)
			{
				this.HandLink_PositionChild_LocalPlayer(link);
			}
			else
			{
				this.playerRigidBody.transform.position += vector;
			}
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x060062FE RID: 25342 RVA: 0x0024514C File Offset: 0x0024334C
		private void HandLink_PositionBoth_BothHands(HandLink link1, HandLink link2)
		{
			Vector3 a = (link1.grabbedLink.transform.position - link1.transform.position) * 0.5f;
			Vector3 b = (link2.grabbedLink.transform.position - link2.transform.position) * 0.5f;
			Vector3 vector = (a + b) * 0.5f;
			bool flag;
			bool flag2;
			link1.grabbedLink.myRig.TrySweptOffsetMove(-vector, out flag, out flag2);
			if (flag || flag2)
			{
				this.HandLink_PositionChild_LocalPlayer(link1, link2);
			}
			else
			{
				this.playerRigidBody.transform.position += vector;
			}
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x060062FF RID: 25343 RVA: 0x00245214 File Offset: 0x00243414
		private void HandLink_PositionChild_LocalPlayer(HandLink parentLink)
		{
			Vector3 b = parentLink.grabbedLink.transform.position - parentLink.transform.position;
			this.playerRigidBody.transform.position += b;
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x06006300 RID: 25344 RVA: 0x00245270 File Offset: 0x00243470
		private void HandLink_PositionChild_LocalPlayer(HandLink linkA, HandLink linkB)
		{
			Vector3 a = linkA.grabbedLink.transform.position - linkA.transform.position;
			Vector3 b = linkB.grabbedLink.transform.position - linkB.transform.position;
			this.playerRigidBody.transform.position += (a + b) * 0.5f;
			this.playerRigidBody.linearVelocity = Vector3.zero;
		}

		// Token: 0x06006301 RID: 25345 RVA: 0x002452FC File Offset: 0x002434FC
		private void HandLink_PositionChild_RemotePlayer(HandLink childLink)
		{
			Vector3 movement = childLink.transform.position - childLink.grabbedLink.transform.position;
			bool flag;
			bool flag2;
			childLink.grabbedLink.myRig.TrySweptOffsetMove(movement, out flag, out flag2);
			if (flag || flag2)
			{
				this.HandLink_PositionChild_LocalPlayer(childLink);
			}
		}

		// Token: 0x06006302 RID: 25346 RVA: 0x0024534C File Offset: 0x0024354C
		private void HandLink_PositionChild_RemotePlayer_BothHands(HandLink childLink1, HandLink childLink2)
		{
			Vector3 a = childLink1.transform.position - childLink1.grabbedLink.transform.position;
			Vector3 b = childLink2.transform.position - childLink2.grabbedLink.transform.position;
			Vector3 movement = (a + b) * 0.5f;
			bool flag;
			bool flag2;
			childLink1.grabbedLink.myRig.TrySweptOffsetMove(movement, out flag, out flag2);
			if (flag || flag2)
			{
				this.HandLink_PositionChild_LocalPlayer(childLink1, childLink2);
			}
		}

		// Token: 0x06006303 RID: 25347 RVA: 0x002453D0 File Offset: 0x002435D0
		private bool IterativeCollisionSphereCast(Vector3 startPosition, float sphereRadius, Vector3 movementVector, Vector3 boostVector, out Vector3 endPosition, bool singleHand, out float slipPercentage, out RaycastHit iterativeHitInfo, bool fullSlide)
		{
			slipPercentage = this.defaultSlideFactor;
			if (!this.CollisionsSphereCast(startPosition, sphereRadius, movementVector, out endPosition, out this.tempIterativeHit))
			{
				iterativeHitInfo = this.tempIterativeHit;
				endPosition = Vector3.zero;
				return false;
			}
			this.firstPosition = endPosition;
			iterativeHitInfo = this.tempIterativeHit;
			this.slideFactor = this.GetSlidePercentage(iterativeHitInfo);
			slipPercentage = ((this.slideFactor != this.defaultSlideFactor) ? this.slideFactor : ((!singleHand) ? this.defaultSlideFactor : 0.001f));
			if (fullSlide)
			{
				slipPercentage = 1f;
			}
			this.movementToProjectedAboveCollisionPlane = Vector3.ProjectOnPlane(startPosition + movementVector - this.firstPosition, iterativeHitInfo.normal) * slipPercentage;
			Vector3 vector = Vector3.zero;
			if (boostVector.IsLongerThan(0f))
			{
				vector = Vector3.ProjectOnPlane(boostVector, iterativeHitInfo.normal);
				this.movementToProjectedAboveCollisionPlane += vector;
				this.CollisionsSphereCast(this.firstPosition, sphereRadius, vector, out endPosition, out this.tempIterativeHit);
				this.firstPosition = endPosition;
			}
			if (this.CollisionsSphereCast(this.firstPosition, sphereRadius, this.movementToProjectedAboveCollisionPlane, out endPosition, out this.tempIterativeHit))
			{
				iterativeHitInfo = this.tempIterativeHit;
				return true;
			}
			if (this.CollisionsSphereCast(this.movementToProjectedAboveCollisionPlane + this.firstPosition, sphereRadius, startPosition + movementVector + vector - (this.movementToProjectedAboveCollisionPlane + this.firstPosition), out endPosition, out this.tempIterativeHit))
			{
				iterativeHitInfo = this.tempIterativeHit;
				return true;
			}
			endPosition = Vector3.zero;
			return false;
		}

		// Token: 0x06006304 RID: 25348 RVA: 0x0024558C File Offset: 0x0024378C
		private bool CollisionsSphereCast(Vector3 startPosition, float sphereRadius, Vector3 movementVector, out Vector3 finalPosition, out RaycastHit collisionsHitInfo)
		{
			this.MaxSphereSizeForNoOverlap(sphereRadius, startPosition, false, out this.maxSphereSize1);
			bool flag = false;
			this.ClearRaycasthitBuffer(ref this.rayCastNonAllocColliders);
			this.bufferCount = Physics.SphereCastNonAlloc(startPosition, this.maxSphereSize1, movementVector.normalized, this.rayCastNonAllocColliders, movementVector.magnitude, this.locomotionEnabledLayers.value);
			if (this.bufferCount > 0)
			{
				this.tempHitInfo = this.rayCastNonAllocColliders[0];
				for (int i = 0; i < this.bufferCount; i++)
				{
					if (this.tempHitInfo.distance > 0f && (!flag || this.rayCastNonAllocColliders[i].distance < this.tempHitInfo.distance))
					{
						flag = true;
						this.tempHitInfo = this.rayCastNonAllocColliders[i];
					}
				}
			}
			if (flag)
			{
				collisionsHitInfo = this.tempHitInfo;
				finalPosition = collisionsHitInfo.point + collisionsHitInfo.normal * sphereRadius;
				this.ClearRaycasthitBuffer(ref this.rayCastNonAllocColliders);
				this.bufferCount = Physics.RaycastNonAlloc(startPosition, (finalPosition - startPosition).normalized, this.rayCastNonAllocColliders, (finalPosition - startPosition).magnitude, this.locomotionEnabledLayers.value, QueryTriggerInteraction.Ignore);
				if (this.bufferCount > 0)
				{
					this.tempHitInfo = this.rayCastNonAllocColliders[0];
					for (int j = 0; j < this.bufferCount; j++)
					{
						if (this.rayCastNonAllocColliders[j].collider && this.rayCastNonAllocColliders[j].distance < this.tempHitInfo.distance)
						{
							this.tempHitInfo = this.rayCastNonAllocColliders[j];
						}
					}
					finalPosition = startPosition + movementVector.normalized * this.tempHitInfo.distance;
				}
				this.MaxSphereSizeForNoOverlap(sphereRadius, finalPosition, false, out this.maxSphereSize2);
				this.ClearRaycasthitBuffer(ref this.rayCastNonAllocColliders);
				this.bufferCount = Physics.SphereCastNonAlloc(startPosition, Mathf.Min(this.maxSphereSize1, this.maxSphereSize2), (finalPosition - startPosition).normalized, this.rayCastNonAllocColliders, (finalPosition - startPosition).magnitude, this.locomotionEnabledLayers.value);
				if (this.bufferCount > 0)
				{
					this.tempHitInfo = this.rayCastNonAllocColliders[0];
					for (int k = 0; k < this.bufferCount; k++)
					{
						if (this.rayCastNonAllocColliders[k].collider != null && this.rayCastNonAllocColliders[k].distance < this.tempHitInfo.distance)
						{
							this.tempHitInfo = this.rayCastNonAllocColliders[k];
						}
					}
					finalPosition = startPosition + this.tempHitInfo.distance * (finalPosition - startPosition).normalized;
					collisionsHitInfo = this.tempHitInfo;
				}
				return true;
			}
			this.ClearRaycasthitBuffer(ref this.rayCastNonAllocColliders);
			this.bufferCount = Physics.RaycastNonAlloc(startPosition, movementVector.normalized, this.rayCastNonAllocColliders, movementVector.magnitude, this.locomotionEnabledLayers.value);
			if (this.bufferCount > 0)
			{
				this.tempHitInfo = this.rayCastNonAllocColliders[0];
				for (int l = 0; l < this.bufferCount; l++)
				{
					if (this.rayCastNonAllocColliders[l].collider != null && this.rayCastNonAllocColliders[l].distance < this.tempHitInfo.distance)
					{
						this.tempHitInfo = this.rayCastNonAllocColliders[l];
					}
				}
				collisionsHitInfo = this.tempHitInfo;
				finalPosition = startPosition;
				return true;
			}
			finalPosition = startPosition + movementVector;
			collisionsHitInfo = default(RaycastHit);
			return false;
		}

		// Token: 0x06006305 RID: 25349 RVA: 0x0024599C File Offset: 0x00243B9C
		public float GetSlidePercentage(RaycastHit raycastHit)
		{
			if (this.IsFrozen && GorillaGameManager.instance is GorillaFreezeTagManager)
			{
				return this.FreezeTagSlidePercentage();
			}
			this.currentOverride = raycastHit.collider.gameObject.GetComponent<GorillaSurfaceOverride>();
			BasePlatform component = raycastHit.collider.gameObject.GetComponent<BasePlatform>();
			if (component != null)
			{
				this.currentPlatform = component;
			}
			if (this.currentOverride != null)
			{
				if (this.currentOverride.slidePercentageOverride >= 0f)
				{
					return this.currentOverride.slidePercentageOverride;
				}
				this.currentMaterialIndex = this.currentOverride.overrideIndex;
				if (this.currentMaterialIndex < 0 || this.currentMaterialIndex >= this.materialData.Count)
				{
					return this.defaultSlideFactor;
				}
				if (!this.materialData[this.currentMaterialIndex].overrideSlidePercent)
				{
					return this.defaultSlideFactor;
				}
				return this.materialData[this.currentMaterialIndex].slidePercent;
			}
			else
			{
				this.meshCollider = (raycastHit.collider as MeshCollider);
				if (this.meshCollider == null || this.meshCollider.sharedMesh == null || this.meshCollider.convex)
				{
					return this.defaultSlideFactor;
				}
				this.collidedMesh = this.meshCollider.sharedMesh;
				if (!this.meshTrianglesDict.TryGetValue(this.collidedMesh, out this.sharedMeshTris))
				{
					this.sharedMeshTris = this.collidedMesh.triangles;
					this.meshTrianglesDict.Add(this.collidedMesh, (int[])this.sharedMeshTris.Clone());
				}
				this.vertex1 = this.sharedMeshTris[raycastHit.triangleIndex * 3];
				this.vertex2 = this.sharedMeshTris[raycastHit.triangleIndex * 3 + 1];
				this.vertex3 = this.sharedMeshTris[raycastHit.triangleIndex * 3 + 2];
				this.slideRenderer = raycastHit.collider.GetComponent<Renderer>();
				if (this.slideRenderer != null)
				{
					this.slideRenderer.GetSharedMaterials(this.tempMaterialArray);
				}
				else
				{
					this.tempMaterialArray.Clear();
				}
				if (this.tempMaterialArray.Count > 1)
				{
					for (int i = 0; i < this.tempMaterialArray.Count; i++)
					{
						this.collidedMesh.GetTriangles(this.trianglesList, i);
						int j = 0;
						while (j < this.trianglesList.Count)
						{
							if (this.trianglesList[j] == this.vertex1 && this.trianglesList[j + 1] == this.vertex2 && this.trianglesList[j + 2] == this.vertex3)
							{
								this.findMatName = this.tempMaterialArray[i].name;
								if (this.findMatName.EndsWith("Uber"))
								{
									string text = this.findMatName;
									this.findMatName = text.Substring(0, text.Length - 4);
								}
								this.foundMatData = this.materialData.Find((GTPlayer.MaterialData matData) => matData.matName == this.findMatName);
								this.currentMaterialIndex = this.materialData.FindIndex((GTPlayer.MaterialData matData) => matData.matName == this.findMatName);
								if (this.currentMaterialIndex == -1)
								{
									this.currentMaterialIndex = 0;
								}
								if (!this.foundMatData.overrideSlidePercent)
								{
									return this.defaultSlideFactor;
								}
								return this.foundMatData.slidePercent;
							}
							else
							{
								j += 3;
							}
						}
					}
				}
				else if (this.tempMaterialArray.Count > 0)
				{
					return this.defaultSlideFactor;
				}
				this.currentMaterialIndex = 0;
				return this.defaultSlideFactor;
			}
		}

		// Token: 0x06006306 RID: 25350 RVA: 0x00245D34 File Offset: 0x00243F34
		public bool IsTouchingMovingSurface(Vector3 rayOrigin, RaycastHit raycastHit, out int movingSurfaceId, out bool sideTouch, out bool isMonkeBlock)
		{
			movingSurfaceId = -1;
			sideTouch = false;
			isMonkeBlock = false;
			float num = Vector3.Dot(rayOrigin - raycastHit.point, Vector3.up);
			if (num < -0.3f)
			{
				return false;
			}
			if (num < 0f)
			{
				sideTouch = true;
			}
			if (raycastHit.collider == null)
			{
				return false;
			}
			MovingSurface component = raycastHit.collider.GetComponent<MovingSurface>();
			if (component != null)
			{
				isMonkeBlock = false;
				movingSurfaceId = component.GetID();
				return true;
			}
			if (!BuilderTable.IsLocalPlayerInBuilderZone())
			{
				return false;
			}
			BuilderPiece builderPieceFromCollider = BuilderPiece.GetBuilderPieceFromCollider(raycastHit.collider);
			if (builderPieceFromCollider != null && builderPieceFromCollider.IsPieceMoving())
			{
				isMonkeBlock = true;
				movingSurfaceId = builderPieceFromCollider.pieceId;
				this.lastMonkeBlock = builderPieceFromCollider;
				return true;
			}
			sideTouch = false;
			return false;
		}

		// Token: 0x06006307 RID: 25351 RVA: 0x00245DF0 File Offset: 0x00243FF0
		public void Turn(float degrees)
		{
			Vector3 position = this.headCollider.transform.position;
			bool flag = this.rightHand.isColliding || this.rightHand.isHolding;
			bool flag2 = this.leftHand.isColliding || this.leftHand.isHolding;
			if (flag != flag2 && flag)
			{
				position = this.rightHand.controllerTransform.position;
			}
			if (flag != flag2 && flag2)
			{
				position = this.leftHand.controllerTransform.position;
			}
			this.turnParent.transform.RotateAround(position, base.transform.up, degrees);
			this.degreesTurnedThisFrame = degrees;
			this.averagedVelocity = Vector3.zero;
			for (int i = 0; i < this.velocityHistory.Length; i++)
			{
				this.velocityHistory[i] = Quaternion.Euler(0f, degrees, 0f) * this.velocityHistory[i];
				this.averagedVelocity += this.velocityHistory[i];
			}
			this.averagedVelocity /= (float)this.velocityHistorySize;
		}

		// Token: 0x06006308 RID: 25352 RVA: 0x00245F24 File Offset: 0x00244124
		public void BeginClimbing(GorillaClimbable climbable, GorillaHandClimber hand, GorillaClimbableRef climbableRef = null)
		{
			if (this.currentClimber != null)
			{
				this.EndClimbing(this.currentClimber, true, false);
			}
			try
			{
				Action<GorillaHandClimber, GorillaClimbableRef> onBeforeClimb = climbable.onBeforeClimb;
				if (onBeforeClimb != null)
				{
					onBeforeClimb(hand, climbableRef);
				}
			}
			catch (Exception message)
			{
				Debug.LogError(message);
			}
			Rigidbody rigidbody;
			climbable.TryGetComponent<Rigidbody>(out rigidbody);
			this.VerifyClimbHelper();
			this.climbHelper.SetParent(climbable.transform);
			this.climbHelper.position = hand.transform.position;
			Vector3 localPosition = this.climbHelper.localPosition;
			if (climbable.snapX)
			{
				GTPlayer.<BeginClimbing>g__SnapAxis|405_0(ref localPosition.x, climbable.maxDistanceSnap);
			}
			if (climbable.snapY)
			{
				GTPlayer.<BeginClimbing>g__SnapAxis|405_0(ref localPosition.y, climbable.maxDistanceSnap);
			}
			if (climbable.snapZ)
			{
				GTPlayer.<BeginClimbing>g__SnapAxis|405_0(ref localPosition.z, climbable.maxDistanceSnap);
			}
			this.climbHelperTargetPos = localPosition;
			climbable.isBeingClimbed = true;
			hand.isClimbing = true;
			this.currentClimbable = climbable;
			this.currentClimber = hand;
			this.isClimbing = true;
			if (climbable.climbOnlyWhileSmall)
			{
				BuilderPiece componentInParent = climbable.GetComponentInParent<BuilderPiece>();
				if (componentInParent != null && componentInParent.IsPieceMoving())
				{
					this.isClimbableMoving = true;
					this.lastClimbableRotation = climbable.transform.rotation;
				}
				else
				{
					this.isClimbableMoving = false;
				}
			}
			else
			{
				this.isClimbableMoving = false;
			}
			GorillaRopeSegment gorillaRopeSegment;
			GorillaZipline gorillaZipline;
			PhotonView view;
			PhotonViewXSceneRef photonViewXSceneRef;
			if (climbable.TryGetComponent<GorillaRopeSegment>(out gorillaRopeSegment) && gorillaRopeSegment.swing)
			{
				this.currentSwing = gorillaRopeSegment.swing;
				this.currentSwing.AttachLocalPlayer(hand.xrNode, climbable.transform, this.climbHelperTargetPos, this.averagedVelocity);
			}
			else if (climbable.transform.parent && climbable.transform.parent.TryGetComponent<GorillaZipline>(out gorillaZipline))
			{
				this.currentZipline = gorillaZipline;
			}
			else if (climbable.TryGetComponent<PhotonView>(out view))
			{
				VRRig.AttachLocalPlayerToPhotonView(view, hand.xrNode, this.climbHelperTargetPos, this.averagedVelocity);
			}
			else if (climbable.TryGetComponent<PhotonViewXSceneRef>(out photonViewXSceneRef))
			{
				VRRig.AttachLocalPlayerToPhotonView(photonViewXSceneRef.photonView, hand.xrNode, this.climbHelperTargetPos, this.averagedVelocity);
			}
			GorillaTagger.Instance.StartVibration(this.currentClimber.xrNode == XRNode.LeftHand, 0.6f, 0.06f);
			if (climbable.clip)
			{
				GorillaTagger.Instance.offlineVRRig.PlayClimbSound(climbable.clip, hand.xrNode == XRNode.LeftHand);
			}
		}

		// Token: 0x06006309 RID: 25353 RVA: 0x0007CF1C File Offset: 0x0007B11C
		private void VerifyClimbHelper()
		{
			if (this.climbHelper == null || this.climbHelper.gameObject == null)
			{
				this.climbHelper = new GameObject("Climb Helper").transform;
			}
		}

		// Token: 0x0600630A RID: 25354 RVA: 0x00246190 File Offset: 0x00244390
		public void EndClimbing(GorillaHandClimber hand, bool startingNewClimb, bool doDontReclimb = false)
		{
			if (hand != this.currentClimber)
			{
				return;
			}
			hand.SetCanRelease(true);
			if (!startingNewClimb)
			{
				this.enablePlayerGravity(true);
			}
			Rigidbody rigidbody = null;
			if (this.currentClimbable)
			{
				this.currentClimbable.TryGetComponent<Rigidbody>(out rigidbody);
				this.currentClimbable.isBeingClimbed = false;
			}
			Vector3 vector = Vector3.zero;
			if (this.currentClimber)
			{
				this.currentClimber.isClimbing = false;
				if (doDontReclimb)
				{
					this.currentClimber.dontReclimbLast = this.currentClimbable;
				}
				else
				{
					this.currentClimber.dontReclimbLast = null;
				}
				this.currentClimber.queuedToBecomeValidToGrabAgain = true;
				this.currentClimber.lastAutoReleasePos = this.currentClimber.handRoot.localPosition;
				if (!startingNewClimb && this.currentClimbable)
				{
					GorillaVelocityTracker interactPointVelocityTracker = this.GetInteractPointVelocityTracker(this.currentClimber.xrNode == XRNode.LeftHand);
					if (rigidbody)
					{
						this.playerRigidBody.linearVelocity = rigidbody.linearVelocity;
					}
					else if (this.currentSwing)
					{
						this.playerRigidBody.linearVelocity = this.currentSwing.velocityTracker.GetAverageVelocity(true, 0.25f, false);
					}
					else if (this.currentZipline)
					{
						this.playerRigidBody.linearVelocity = this.currentZipline.GetCurrentDirection() * this.currentZipline.currentSpeed;
					}
					else
					{
						this.playerRigidBody.linearVelocity = Vector3.zero;
					}
					vector = this.turnParent.transform.rotation * -interactPointVelocityTracker.GetAverageVelocity(false, 0.1f, true) * this.scale;
					vector = Vector3.ClampMagnitude(vector, 5.5f * this.scale);
					this.playerRigidBody.AddForce(vector, ForceMode.VelocityChange);
				}
			}
			if (this.currentSwing)
			{
				this.currentSwing.DetachLocalPlayer();
			}
			PhotonView photonView;
			PhotonViewXSceneRef photonViewXSceneRef;
			if (this.currentClimbable.TryGetComponent<PhotonView>(out photonView) || this.currentClimbable.TryGetComponent<PhotonViewXSceneRef>(out photonViewXSceneRef) || this.currentClimbable.IsPlayerAttached)
			{
				VRRig.DetachLocalPlayerFromPhotonView();
			}
			if (!startingNewClimb && vector.magnitude > 2f && this.currentClimbable && this.currentClimbable.clipOnFullRelease)
			{
				GorillaTagger.Instance.offlineVRRig.PlayClimbSound(this.currentClimbable.clipOnFullRelease, hand.xrNode == XRNode.LeftHand);
			}
			this.currentClimbable = null;
			this.currentClimber = null;
			this.currentSwing = null;
			this.currentZipline = null;
			this.isClimbing = false;
		}

		// Token: 0x0600630B RID: 25355 RVA: 0x0007CF54 File Offset: 0x0007B154
		public void ResetRigidbodyInterpolation()
		{
			this.playerRigidBody.interpolation = this.playerRigidbodyInterpolationDefault;
		}

		// Token: 0x17000977 RID: 2423
		// (get) Token: 0x0600630C RID: 25356 RVA: 0x0007CF67 File Offset: 0x0007B167
		// (set) Token: 0x0600630D RID: 25357 RVA: 0x0007CF74 File Offset: 0x0007B174
		public RigidbodyInterpolation RigidbodyInterpolation
		{
			get
			{
				return this.playerRigidBody.interpolation;
			}
			set
			{
				this.playerRigidBody.interpolation = value;
			}
		}

		// Token: 0x0600630E RID: 25358 RVA: 0x0007CF82 File Offset: 0x0007B182
		private void enablePlayerGravity(bool useGravity)
		{
			this.playerRigidBody.useGravity = useGravity;
		}

		// Token: 0x0600630F RID: 25359 RVA: 0x0007CF90 File Offset: 0x0007B190
		public void SetVelocity(Vector3 velocity)
		{
			this.playerRigidBody.linearVelocity = velocity;
		}

		// Token: 0x06006310 RID: 25360 RVA: 0x0007CF9E File Offset: 0x0007B19E
		internal void RigidbodyMovePosition(Vector3 pos)
		{
			this.playerRigidBody.MovePosition(pos);
		}

		// Token: 0x06006311 RID: 25361 RVA: 0x00246420 File Offset: 0x00244620
		public void TempFreezeHand(bool isLeft, float freezeDuration)
		{
			(isLeft ? this.leftHand : this.rightHand).TempFreezeHand(freezeDuration);
		}

		// Token: 0x06006312 RID: 25362 RVA: 0x00246448 File Offset: 0x00244648
		private void StoreVelocities()
		{
			this.velocityIndex = (this.velocityIndex + 1) % this.velocityHistorySize;
			this.currentVelocity = (base.transform.position - this.lastPosition - this.MovingSurfaceMovement()) / this.calcDeltaTime;
			this.velocityHistory[this.velocityIndex] = this.currentVelocity;
			this.averagedVelocity = this.velocityHistory.Average();
			this.lastPosition = base.transform.position;
		}

		// Token: 0x06006313 RID: 25363 RVA: 0x002464D8 File Offset: 0x002446D8
		private void AntiTeleportTechnology()
		{
			if ((this.headCollider.transform.position - this.lastHeadPosition).magnitude >= this.teleportThresholdNoVel + this.playerRigidBody.linearVelocity.magnitude * this.calcDeltaTime)
			{
				this.ForceRigidBodySync();
				base.transform.position = base.transform.position + this.lastHeadPosition - this.headCollider.transform.position;
			}
		}

		// Token: 0x06006314 RID: 25364 RVA: 0x00246568 File Offset: 0x00244768
		private bool MaxSphereSizeForNoOverlap(float testRadius, Vector3 checkPosition, bool ignoreOneWay, out float overlapRadiusTest)
		{
			overlapRadiusTest = testRadius;
			this.overlapAttempts = 0;
			int num = 100;
			while (this.overlapAttempts < num && overlapRadiusTest > testRadius * 0.75f)
			{
				this.ClearColliderBuffer(ref this.overlapColliders);
				this.bufferCount = Physics.OverlapSphereNonAlloc(checkPosition, overlapRadiusTest, this.overlapColliders, this.locomotionEnabledLayers.value, QueryTriggerInteraction.Ignore);
				if (ignoreOneWay)
				{
					int num2 = 0;
					for (int i = 0; i < this.bufferCount; i++)
					{
						if (this.overlapColliders[i].CompareTag("NoCrazyCheck"))
						{
							num2++;
						}
					}
					if (num2 == this.bufferCount)
					{
						return true;
					}
				}
				if (this.bufferCount <= 0)
				{
					overlapRadiusTest *= 0.995f;
					return true;
				}
				overlapRadiusTest = Mathf.Lerp(testRadius, 0f, (float)this.overlapAttempts / (float)num);
				this.overlapAttempts++;
			}
			return false;
		}

		// Token: 0x06006315 RID: 25365 RVA: 0x00246648 File Offset: 0x00244848
		private bool CrazyCheck2(float sphereSize, Vector3 startPosition)
		{
			for (int i = 0; i < this.crazyCheckVectors.Length; i++)
			{
				if (this.NonAllocRaycast(startPosition, startPosition + this.crazyCheckVectors[i] * sphereSize) > 0)
				{
					return false;
				}
			}
			return true;
		}

		// Token: 0x06006316 RID: 25366 RVA: 0x00246690 File Offset: 0x00244890
		private int NonAllocRaycast(Vector3 startPosition, Vector3 endPosition)
		{
			Vector3 direction = endPosition - startPosition;
			int num = Physics.RaycastNonAlloc(startPosition, direction, this.rayCastNonAllocColliders, direction.magnitude, this.locomotionEnabledLayers.value, QueryTriggerInteraction.Ignore);
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (!this.rayCastNonAllocColliders[i].collider.gameObject.CompareTag("NoCrazyCheck"))
				{
					num2++;
				}
			}
			return num2;
		}

		// Token: 0x06006317 RID: 25367 RVA: 0x002466FC File Offset: 0x002448FC
		private void ClearColliderBuffer(ref Collider[] colliders)
		{
			for (int i = 0; i < colliders.Length; i++)
			{
				colliders[i] = null;
			}
		}

		// Token: 0x06006318 RID: 25368 RVA: 0x00246720 File Offset: 0x00244920
		private void ClearRaycasthitBuffer(ref RaycastHit[] raycastHits)
		{
			for (int i = 0; i < raycastHits.Length; i++)
			{
				raycastHits[i] = this.emptyHit;
			}
		}

		// Token: 0x06006319 RID: 25369 RVA: 0x0007CFAC File Offset: 0x0007B1AC
		private Vector3 MovingSurfaceMovement()
		{
			return this.refMovement + this.movingSurfaceOffset;
		}

		// Token: 0x0600631A RID: 25370 RVA: 0x0024674C File Offset: 0x0024494C
		private static bool ComputeLocalHitPoint(RaycastHit hit, out Vector3 localHitPoint)
		{
			if (hit.collider == null || hit.point.sqrMagnitude < 0.001f)
			{
				localHitPoint = Vector3.zero;
				return false;
			}
			localHitPoint = hit.collider.transform.InverseTransformPoint(hit.point);
			return true;
		}

		// Token: 0x0600631B RID: 25371 RVA: 0x0007CFBF File Offset: 0x0007B1BF
		private static bool ComputeWorldHitPoint(RaycastHit hit, Vector3 localPoint, out Vector3 worldHitPoint)
		{
			if (hit.collider == null)
			{
				worldHitPoint = Vector3.zero;
				return false;
			}
			worldHitPoint = hit.collider.transform.TransformPoint(localPoint);
			return true;
		}

		// Token: 0x0600631C RID: 25372 RVA: 0x002467AC File Offset: 0x002449AC
		private float ExtraVelMultiplier()
		{
			float num = 1.0125f;
			if (this.leftHand.surfaceOverride != null)
			{
				num = Mathf.Max(num, this.leftHand.surfaceOverride.extraVelMultiplier);
			}
			if (this.rightHand.surfaceOverride != null)
			{
				num = Mathf.Max(num, this.rightHand.surfaceOverride.extraVelMultiplier);
			}
			return num;
		}

		// Token: 0x0600631D RID: 25373 RVA: 0x00246814 File Offset: 0x00244A14
		private float ExtraVelMaxMultiplier()
		{
			float num = 1.07f;
			if (this.leftHand.surfaceOverride != null)
			{
				num = Mathf.Max(num, this.leftHand.surfaceOverride.extraVelMaxMultiplier);
			}
			if (this.rightHand.surfaceOverride != null)
			{
				num = Mathf.Max(num, this.rightHand.surfaceOverride.extraVelMaxMultiplier);
			}
			return num * this.scale;
		}

		// Token: 0x0600631E RID: 25374 RVA: 0x0007CFF6 File Offset: 0x0007B1F6
		public void SetMaximumSlipThisFrame()
		{
			this.leftHand.slipSetToMaxFrameIdx = Time.frameCount;
			this.rightHand.slipSetToMaxFrameIdx = Time.frameCount;
		}

		// Token: 0x0600631F RID: 25375 RVA: 0x0007D018 File Offset: 0x0007B218
		public void SetLeftMaximumSlipThisFrame()
		{
			this.leftHand.slipSetToMaxFrameIdx = Time.frameCount;
		}

		// Token: 0x06006320 RID: 25376 RVA: 0x0007D02A File Offset: 0x0007B22A
		public void SetRightMaximumSlipThisFrame()
		{
			this.rightHand.slipSetToMaxFrameIdx = Time.frameCount;
		}

		// Token: 0x06006321 RID: 25377 RVA: 0x0007D03C File Offset: 0x0007B23C
		public void ChangeLayer(string layerName)
		{
			if (this.layerChanger != null)
			{
				this.layerChanger.ChangeLayer(base.transform.parent, layerName);
			}
		}

		// Token: 0x06006322 RID: 25378 RVA: 0x0007D063 File Offset: 0x0007B263
		public void RestoreLayer()
		{
			if (this.layerChanger != null)
			{
				this.layerChanger.RestoreOriginalLayers();
			}
		}

		// Token: 0x06006323 RID: 25379 RVA: 0x00246888 File Offset: 0x00244A88
		public void OnEnterWaterVolume(Collider playerCollider, WaterVolume volume)
		{
			if (this.activeSizeChangerSettings != null && this.activeSizeChangerSettings.ExpireInWater)
			{
				this.SetNativeScale(null);
			}
			if (playerCollider == this.headCollider)
			{
				if (!this.headOverlappingWaterVolumes.Contains(volume))
				{
					this.headOverlappingWaterVolumes.Add(volume);
					return;
				}
			}
			else if (playerCollider == this.bodyCollider && !this.bodyOverlappingWaterVolumes.Contains(volume))
			{
				this.bodyOverlappingWaterVolumes.Add(volume);
			}
		}

		// Token: 0x06006324 RID: 25380 RVA: 0x0007D07E File Offset: 0x0007B27E
		public void OnExitWaterVolume(Collider playerCollider, WaterVolume volume)
		{
			if (playerCollider == this.headCollider)
			{
				this.headOverlappingWaterVolumes.Remove(volume);
				return;
			}
			if (playerCollider == this.bodyCollider)
			{
				this.bodyOverlappingWaterVolumes.Remove(volume);
			}
		}

		// Token: 0x06006325 RID: 25381 RVA: 0x00246904 File Offset: 0x00244B04
		private bool GetSwimmingVelocityForHand(Vector3 startingHandPosition, Vector3 endingHandPosition, Vector3 palmForwardDirection, float dt, ref WaterVolume contactingWaterVolume, ref WaterVolume.SurfaceQuery waterSurface, out Vector3 swimmingVelocityChange)
		{
			contactingWaterVolume = null;
			this.bufferCount = Physics.OverlapSphereNonAlloc(endingHandPosition, this.minimumRaycastDistance, this.overlapColliders, this.waterLayer.value, QueryTriggerInteraction.Collide);
			if (this.bufferCount > 0)
			{
				float num = float.MinValue;
				for (int i = 0; i < this.bufferCount; i++)
				{
					WaterVolume component = this.overlapColliders[i].GetComponent<WaterVolume>();
					WaterVolume.SurfaceQuery surfaceQuery;
					if (component != null && component.GetSurfaceQueryForPoint(endingHandPosition, out surfaceQuery, false) && surfaceQuery.surfacePoint.y > num)
					{
						num = surfaceQuery.surfacePoint.y;
						contactingWaterVolume = component;
						waterSurface = surfaceQuery;
					}
				}
			}
			if (contactingWaterVolume != null)
			{
				Vector3 a = endingHandPosition - startingHandPosition;
				Vector3 b = Vector3.zero;
				Vector3 b2 = this.playerRigidBody.transform.position - this.lastRigidbodyPosition;
				if (this.turnedThisFrame)
				{
					Vector3 vector = startingHandPosition - this.headCollider.transform.position;
					b = Quaternion.AngleAxis(this.degreesTurnedThisFrame, Vector3.up) * vector - vector;
				}
				float num2 = Vector3.Dot(a - b - b2, palmForwardDirection);
				float num3 = 0f;
				if (num2 > 0f)
				{
					Plane surfacePlane = waterSurface.surfacePlane;
					float distanceToPoint = surfacePlane.GetDistanceToPoint(startingHandPosition);
					float distanceToPoint2 = surfacePlane.GetDistanceToPoint(endingHandPosition);
					if (distanceToPoint <= 0f && distanceToPoint2 <= 0f)
					{
						num3 = 1f;
					}
					else if (distanceToPoint > 0f && distanceToPoint2 <= 0f)
					{
						num3 = -distanceToPoint2 / (distanceToPoint - distanceToPoint2);
					}
					else if (distanceToPoint <= 0f && distanceToPoint2 > 0f)
					{
						num3 = -distanceToPoint / (distanceToPoint2 - distanceToPoint);
					}
					if (num3 > Mathf.Epsilon)
					{
						float resistance = this.liquidPropertiesList[(int)contactingWaterVolume.LiquidType].resistance;
						swimmingVelocityChange = -palmForwardDirection * num2 * 2f * resistance * num3;
						Vector3 forward = this.mainCamera.transform.forward;
						if (forward.y < 0f)
						{
							Vector3 vector2 = forward.x0z();
							float magnitude = vector2.magnitude;
							vector2 /= magnitude;
							float num4 = Vector3.Dot(swimmingVelocityChange, vector2);
							if (num4 > 0f)
							{
								Vector3 vector3 = vector2 * num4;
								swimmingVelocityChange = swimmingVelocityChange - vector3 + vector3 * magnitude + Vector3.up * forward.y * num4;
							}
						}
						return true;
					}
				}
			}
			swimmingVelocityChange = Vector3.zero;
			return false;
		}

		// Token: 0x06006326 RID: 25382 RVA: 0x00246BC0 File Offset: 0x00244DC0
		private bool CheckWaterSurfaceJump(Vector3 startingHandPosition, Vector3 endingHandPosition, Vector3 palmForwardDirection, Vector3 handAvgVelocity, PlayerSwimmingParameters parameters, WaterVolume contactingWaterVolume, WaterVolume.SurfaceQuery waterSurface, out Vector3 jumpVelocity)
		{
			if (contactingWaterVolume != null)
			{
				Plane surfacePlane = waterSurface.surfacePlane;
				bool flag = handAvgVelocity.sqrMagnitude > parameters.waterSurfaceJumpHandSpeedThreshold * parameters.waterSurfaceJumpHandSpeedThreshold;
				if (surfacePlane.GetSide(startingHandPosition) && !surfacePlane.GetSide(endingHandPosition) && flag)
				{
					float value = Vector3.Dot(palmForwardDirection, -waterSurface.surfaceNormal);
					float value2 = Vector3.Dot(handAvgVelocity.normalized, -waterSurface.surfaceNormal);
					float d = parameters.waterSurfaceJumpPalmFacingCurve.Evaluate(Mathf.Clamp(value, 0.01f, 0.99f));
					float d2 = parameters.waterSurfaceJumpHandVelocityFacingCurve.Evaluate(Mathf.Clamp(value2, 0.01f, 0.99f));
					jumpVelocity = -handAvgVelocity * parameters.waterSurfaceJumpAmount * d * d2;
					return true;
				}
			}
			jumpVelocity = Vector3.zero;
			return false;
		}

		// Token: 0x06006327 RID: 25383 RVA: 0x0007D0B7 File Offset: 0x0007B2B7
		private bool TryNormalize(Vector3 input, out Vector3 normalized, out float magnitude, float eps = 0.0001f)
		{
			magnitude = input.magnitude;
			if (magnitude > eps)
			{
				normalized = input / magnitude;
				return true;
			}
			normalized = Vector3.zero;
			return false;
		}

		// Token: 0x06006328 RID: 25384 RVA: 0x0007D0E4 File Offset: 0x0007B2E4
		private bool TryNormalizeDown(Vector3 input, out Vector3 normalized, out float magnitude, float eps = 0.0001f)
		{
			magnitude = input.magnitude;
			if (magnitude > 1f)
			{
				normalized = input / magnitude;
				return true;
			}
			if (magnitude >= eps)
			{
				normalized = input;
				return true;
			}
			normalized = Vector3.zero;
			return false;
		}

		// Token: 0x06006329 RID: 25385 RVA: 0x00246CBC File Offset: 0x00244EBC
		private float FreezeTagSlidePercentage()
		{
			if (this.materialData[this.currentMaterialIndex].overrideSlidePercent && this.materialData[this.currentMaterialIndex].slidePercent > this.freezeTagHandSlidePercent)
			{
				return this.materialData[this.currentMaterialIndex].slidePercent;
			}
			return this.freezeTagHandSlidePercent;
		}

		// Token: 0x0600632A RID: 25386 RVA: 0x00246D1C File Offset: 0x00244F1C
		private void OnCollisionStay(UnityEngine.Collision collision)
		{
			this.bodyCollisionContactsCount = collision.GetContacts(this.bodyCollisionContacts);
			float num = -1f;
			for (int i = 0; i < this.bodyCollisionContactsCount; i++)
			{
				float num2 = Vector3.Dot(this.bodyCollisionContacts[i].normal, Vector3.up);
				if (num2 > num)
				{
					this.bodyGroundContact = this.bodyCollisionContacts[i];
					num = num2;
				}
			}
			float num3 = 0.5f;
			if (num > num3)
			{
				this.bodyGroundContactTime = Time.time;
			}
		}

		// Token: 0x0600632B RID: 25387 RVA: 0x00246DA4 File Offset: 0x00244FA4
		public void DoLaunch(Vector3 velocity)
		{
			GTPlayer.<DoLaunch>d__441 <DoLaunch>d__;
			<DoLaunch>d__.<>t__builder = AsyncVoidMethodBuilder.Create();
			<DoLaunch>d__.<>4__this = this;
			<DoLaunch>d__.velocity = velocity;
			<DoLaunch>d__.<>1__state = -1;
			<DoLaunch>d__.<>t__builder.Start<GTPlayer.<DoLaunch>d__441>(ref <DoLaunch>d__);
		}

		// Token: 0x0600632C RID: 25388 RVA: 0x0007D123 File Offset: 0x0007B323
		private void OnEnable()
		{
			RoomSystem.JoinedRoomEvent += new Action(this.OnJoinedRoom);
		}

		// Token: 0x0600632D RID: 25389 RVA: 0x0007D140 File Offset: 0x0007B340
		private void OnJoinedRoom()
		{
			if (this.activeSizeChangerSettings != null && this.activeSizeChangerSettings.ExpireOnRoomJoin)
			{
				this.SetNativeScale(null);
			}
		}

		// Token: 0x0600632E RID: 25390 RVA: 0x0007D15E File Offset: 0x0007B35E
		private void OnDisable()
		{
			RoomSystem.JoinedRoomEvent -= new Action(this.OnJoinedRoom);
		}

		// Token: 0x0600632F RID: 25391 RVA: 0x0007D17B File Offset: 0x0007B37B
		public void ForceRigidBodySync()
		{
			this.forceRBSync = true;
		}

		// Token: 0x06006330 RID: 25392 RVA: 0x0007D184 File Offset: 0x0007B384
		internal void ClearHandHolds()
		{
			this.leftHand.isHolding = false;
			this.rightHand.isHolding = false;
			this.wasHoldingHandhold = false;
			this.activeHandHold = default(GTPlayer.HandHoldState);
			this.secondaryHandHold = default(GTPlayer.HandHoldState);
			this.OnChangeActiveHandhold();
		}

		// Token: 0x06006331 RID: 25393 RVA: 0x00246DE4 File Offset: 0x00244FE4
		internal void AddHandHold(Transform objectHeld, Vector3 localPositionHeld, GorillaGrabber grabber, bool forLeftHand, bool rotatePlayerWhenHeld, out Vector3 grabbedVelocity)
		{
			if (!this.leftHand.isHolding && !this.rightHand.isHolding)
			{
				grabbedVelocity = -this.bodyCollider.attachedRigidbody.linearVelocity;
				this.playerRigidBody.AddForce(grabbedVelocity, ForceMode.VelocityChange);
			}
			else
			{
				grabbedVelocity = Vector3.zero;
			}
			this.secondaryHandHold = this.activeHandHold;
			Vector3 position = grabber.transform.position;
			this.activeHandHold = new GTPlayer.HandHoldState
			{
				grabber = grabber,
				objectHeld = objectHeld,
				localPositionHeld = localPositionHeld,
				localRotationalOffset = grabber.transform.rotation.eulerAngles.y - objectHeld.rotation.eulerAngles.y,
				applyRotation = rotatePlayerWhenHeld
			};
			if (forLeftHand)
			{
				this.leftHand.isHolding = true;
			}
			else
			{
				this.rightHand.isHolding = true;
			}
			this.OnChangeActiveHandhold();
		}

		// Token: 0x06006332 RID: 25394 RVA: 0x00246EE8 File Offset: 0x002450E8
		internal void RemoveHandHold(GorillaGrabber grabber, bool forLeftHand)
		{
			this.activeHandHold.objectHeld == grabber;
			if (this.activeHandHold.grabber == grabber)
			{
				this.activeHandHold = this.secondaryHandHold;
			}
			this.secondaryHandHold = default(GTPlayer.HandHoldState);
			if (forLeftHand)
			{
				this.leftHand.isHolding = false;
			}
			else
			{
				this.rightHand.isHolding = false;
			}
			this.OnChangeActiveHandhold();
		}

		// Token: 0x06006333 RID: 25395 RVA: 0x00246F58 File Offset: 0x00245158
		private void OnChangeActiveHandhold()
		{
			if (this.activeHandHold.objectHeld != null)
			{
				PhotonView view;
				if (this.activeHandHold.objectHeld.TryGetComponent<PhotonView>(out view))
				{
					VRRig.AttachLocalPlayerToPhotonView(view, this.activeHandHold.grabber.XrNode, this.activeHandHold.localPositionHeld, this.averagedVelocity);
					return;
				}
				PhotonViewXSceneRef photonViewXSceneRef;
				if (this.activeHandHold.objectHeld.TryGetComponent<PhotonViewXSceneRef>(out photonViewXSceneRef))
				{
					PhotonView photonView = photonViewXSceneRef.photonView;
					if (photonView != null)
					{
						VRRig.AttachLocalPlayerToPhotonView(photonView, this.activeHandHold.grabber.XrNode, this.activeHandHold.localPositionHeld, this.averagedVelocity);
						return;
					}
				}
				BuilderPieceHandHold builderPieceHandHold;
				if (this.activeHandHold.objectHeld.TryGetComponent<BuilderPieceHandHold>(out builderPieceHandHold) && builderPieceHandHold.IsHandHoldMoving())
				{
					this.isHandHoldMoving = true;
					this.lastHandHoldRotation = builderPieceHandHold.transform.rotation;
					this.movingHandHoldReleaseVelocity = this.playerRigidBody.linearVelocity;
				}
				else
				{
					this.isHandHoldMoving = false;
					this.lastHandHoldRotation = Quaternion.identity;
					this.movingHandHoldReleaseVelocity = Vector3.zero;
				}
			}
			VRRig.DetachLocalPlayerFromPhotonView();
		}

		// Token: 0x06006334 RID: 25396 RVA: 0x00247068 File Offset: 0x00245268
		private void FixedUpdate_HandHolds(float timeDelta)
		{
			if (this.activeHandHold.objectHeld == null)
			{
				if (this.wasHoldingHandhold)
				{
					this.playerRigidBody.linearVelocity = Vector3.ClampMagnitude(this.secondLastPreHandholdVelocity, 5.5f * this.scale);
				}
				this.wasHoldingHandhold = false;
				return;
			}
			Vector3 vector = this.activeHandHold.objectHeld.TransformPoint(this.activeHandHold.localPositionHeld);
			Vector3 position = this.activeHandHold.grabber.transform.position;
			this.secondLastPreHandholdVelocity = this.lastPreHandholdVelocity;
			this.lastPreHandholdVelocity = this.playerRigidBody.linearVelocity;
			this.wasHoldingHandhold = true;
			if (this.isHandHoldMoving)
			{
				this.lastPreHandholdVelocity = this.movingHandHoldReleaseVelocity;
				this.playerRigidBody.linearVelocity = Vector3.zero;
				Vector3 vector2 = vector - position;
				this.playerRigidBody.transform.position += vector2;
				this.movingHandHoldReleaseVelocity = vector2 / timeDelta;
				Quaternion rotationDelta = this.activeHandHold.objectHeld.rotation * Quaternion.Inverse(this.lastHandHoldRotation);
				this.RotateWithSurface(rotationDelta, vector);
				this.lastHandHoldRotation = this.activeHandHold.objectHeld.rotation;
				return;
			}
			this.playerRigidBody.linearVelocity = (vector - position) / timeDelta;
			if (this.activeHandHold.applyRotation)
			{
				this.turnParent.transform.RotateAround(vector, base.transform.up, this.activeHandHold.localRotationalOffset - (this.activeHandHold.grabber.transform.rotation.eulerAngles.y - this.activeHandHold.objectHeld.rotation.eulerAngles.y));
			}
		}

		// Token: 0x06006335 RID: 25397 RVA: 0x00247238 File Offset: 0x00245438
		public GTPlayer()
		{
		}

		// Token: 0x06006338 RID: 25400 RVA: 0x0007D1D6 File Offset: 0x0007B3D6
		[CompilerGenerated]
		internal static void <BeginClimbing>g__SnapAxis|405_0(ref float val, float maxDist)
		{
			if (val > maxDist)
			{
				val = maxDist;
				return;
			}
			if (val < -maxDist)
			{
				val = -maxDist;
			}
		}

		// Token: 0x04007124 RID: 28964
		private static GTPlayer _instance;

		// Token: 0x04007125 RID: 28965
		public static bool hasInstance;

		// Token: 0x04007126 RID: 28966
		public Camera mainCamera;

		// Token: 0x04007127 RID: 28967
		public SphereCollider headCollider;

		// Token: 0x04007128 RID: 28968
		public CapsuleCollider bodyCollider;

		// Token: 0x04007129 RID: 28969
		private float bodyInitialRadius;

		// Token: 0x0400712A RID: 28970
		private float bodyInitialHeight;

		// Token: 0x0400712B RID: 28971
		private RaycastHit bodyHitInfo;

		// Token: 0x0400712C RID: 28972
		private RaycastHit lastHitInfoHand;

		// Token: 0x0400712D RID: 28973
		public GorillaVelocityTracker bodyVelocityTracker;

		// Token: 0x0400712E RID: 28974
		public PlayerAudioManager audioManager;

		// Token: 0x0400712F RID: 28975
		[SerializeField]
		private GTPlayer.HandState leftHand;

		// Token: 0x04007130 RID: 28976
		[SerializeField]
		private GTPlayer.HandState rightHand;

		// Token: 0x04007131 RID: 28977
		private GTPlayer.HandState[] stiltStates = new GTPlayer.HandState[12];

		// Token: 0x04007132 RID: 28978
		private bool anyHandIsColliding;

		// Token: 0x04007133 RID: 28979
		private bool anyHandWasColliding;

		// Token: 0x04007134 RID: 28980
		private bool anyHandIsSliding;

		// Token: 0x04007135 RID: 28981
		private bool anyHandWasSliding;

		// Token: 0x04007136 RID: 28982
		private bool anyHandIsSticking;

		// Token: 0x04007137 RID: 28983
		private bool anyHandWasSticking;

		// Token: 0x04007138 RID: 28984
		private bool forceRBSync;

		// Token: 0x04007139 RID: 28985
		public Vector3 lastHeadPosition;

		// Token: 0x0400713A RID: 28986
		private Vector3 lastRigidbodyPosition;

		// Token: 0x0400713B RID: 28987
		private Rigidbody playerRigidBody;

		// Token: 0x0400713C RID: 28988
		private RigidbodyInterpolation playerRigidbodyInterpolationDefault;

		// Token: 0x0400713D RID: 28989
		public int velocityHistorySize;

		// Token: 0x0400713E RID: 28990
		public float maxArmLength = 1f;

		// Token: 0x0400713F RID: 28991
		public float unStickDistance = 1f;

		// Token: 0x04007140 RID: 28992
		public float velocityLimit;

		// Token: 0x04007141 RID: 28993
		public float slideVelocityLimit;

		// Token: 0x04007142 RID: 28994
		public float maxJumpSpeed;

		// Token: 0x04007143 RID: 28995
		private float _jumpMultiplier;

		// Token: 0x04007144 RID: 28996
		public float minimumRaycastDistance = 0.05f;

		// Token: 0x04007145 RID: 28997
		public float defaultSlideFactor = 0.03f;

		// Token: 0x04007146 RID: 28998
		public float slidingMinimum = 0.9f;

		// Token: 0x04007147 RID: 28999
		public float defaultPrecision = 0.995f;

		// Token: 0x04007148 RID: 29000
		public float teleportThresholdNoVel = 1f;

		// Token: 0x04007149 RID: 29001
		public float frictionConstant = 1f;

		// Token: 0x0400714A RID: 29002
		public float slideControl = 0.00425f;

		// Token: 0x0400714B RID: 29003
		public float stickDepth = 0.01f;

		// Token: 0x0400714C RID: 29004
		private Vector3[] velocityHistory;

		// Token: 0x0400714D RID: 29005
		private Vector3[] slideAverageHistory;

		// Token: 0x0400714E RID: 29006
		private int velocityIndex;

		// Token: 0x0400714F RID: 29007
		private Vector3 currentVelocity;

		// Token: 0x04007150 RID: 29008
		private Vector3 averagedVelocity;

		// Token: 0x04007151 RID: 29009
		private Vector3 lastPosition;

		// Token: 0x04007152 RID: 29010
		public Vector3 bodyOffset;

		// Token: 0x04007153 RID: 29011
		public LayerMask locomotionEnabledLayers;

		// Token: 0x04007154 RID: 29012
		public LayerMask waterLayer;

		// Token: 0x04007155 RID: 29013
		public bool wasHeadTouching;

		// Token: 0x04007156 RID: 29014
		public int currentMaterialIndex;

		// Token: 0x04007157 RID: 29015
		public Vector3 headSlideNormal;

		// Token: 0x04007158 RID: 29016
		public float headSlipPercentage;

		// Token: 0x04007159 RID: 29017
		[SerializeField]
		private Transform cosmeticsHeadTarget;

		// Token: 0x0400715A RID: 29018
		[SerializeField]
		private float nativeScale = 1f;

		// Token: 0x0400715B RID: 29019
		[SerializeField]
		private float scaleMultiplier = 1f;

		// Token: 0x0400715C RID: 29020
		private NativeSizeChangerSettings activeSizeChangerSettings;

		// Token: 0x0400715D RID: 29021
		public bool debugMovement;

		// Token: 0x0400715E RID: 29022
		public bool disableMovement;

		// Token: 0x0400715F RID: 29023
		[NonSerialized]
		public bool inOverlay;

		// Token: 0x04007160 RID: 29024
		[NonSerialized]
		public bool isUserPresent;

		// Token: 0x04007161 RID: 29025
		public GameObject turnParent;

		// Token: 0x04007162 RID: 29026
		public GorillaSurfaceOverride currentOverride;

		// Token: 0x04007163 RID: 29027
		public MaterialDatasSO materialDatasSO;

		// Token: 0x04007164 RID: 29028
		private float degreesTurnedThisFrame;

		// Token: 0x04007165 RID: 29029
		private Vector3 bodyOffsetVector;

		// Token: 0x04007166 RID: 29030
		private Vector3 movementToProjectedAboveCollisionPlane;

		// Token: 0x04007167 RID: 29031
		private MeshCollider meshCollider;

		// Token: 0x04007168 RID: 29032
		private Mesh collidedMesh;

		// Token: 0x04007169 RID: 29033
		private GTPlayer.MaterialData foundMatData;

		// Token: 0x0400716A RID: 29034
		private string findMatName;

		// Token: 0x0400716B RID: 29035
		private int vertex1;

		// Token: 0x0400716C RID: 29036
		private int vertex2;

		// Token: 0x0400716D RID: 29037
		private int vertex3;

		// Token: 0x0400716E RID: 29038
		private List<int> trianglesList = new List<int>(1000000);

		// Token: 0x0400716F RID: 29039
		private Dictionary<Mesh, int[]> meshTrianglesDict = new Dictionary<Mesh, int[]>(128);

		// Token: 0x04007170 RID: 29040
		private int[] sharedMeshTris;

		// Token: 0x04007171 RID: 29041
		private float lastRealTime;

		// Token: 0x04007172 RID: 29042
		private float calcDeltaTime;

		// Token: 0x04007173 RID: 29043
		private float tempRealTime;

		// Token: 0x04007174 RID: 29044
		private Vector3 slideVelocity;

		// Token: 0x04007175 RID: 29045
		private Vector3 slideAverageNormal;

		// Token: 0x04007176 RID: 29046
		private RaycastHit tempHitInfo;

		// Token: 0x04007177 RID: 29047
		private RaycastHit junkHit;

		// Token: 0x04007178 RID: 29048
		private Vector3 firstPosition;

		// Token: 0x04007179 RID: 29049
		private RaycastHit tempIterativeHit;

		// Token: 0x0400717A RID: 29050
		private float maxSphereSize1;

		// Token: 0x0400717B RID: 29051
		private float maxSphereSize2;

		// Token: 0x0400717C RID: 29052
		private Collider[] overlapColliders = new Collider[10];

		// Token: 0x0400717D RID: 29053
		private int overlapAttempts;

		// Token: 0x0400717E RID: 29054
		private float averageSlipPercentage;

		// Token: 0x0400717F RID: 29055
		private Vector3 surfaceDirection;

		// Token: 0x04007180 RID: 29056
		public float iceThreshold = 0.9f;

		// Token: 0x04007181 RID: 29057
		private float bodyMaxRadius;

		// Token: 0x04007182 RID: 29058
		public float bodyLerp = 0.17f;

		// Token: 0x04007183 RID: 29059
		private bool areBothTouching;

		// Token: 0x04007184 RID: 29060
		private float slideFactor;

		// Token: 0x04007185 RID: 29061
		[DebugOption]
		public bool didAJump;

		// Token: 0x04007186 RID: 29062
		private bool updateRB;

		// Token: 0x04007187 RID: 29063
		private Renderer slideRenderer;

		// Token: 0x04007188 RID: 29064
		private RaycastHit[] rayCastNonAllocColliders;

		// Token: 0x04007189 RID: 29065
		private Vector3[] crazyCheckVectors;

		// Token: 0x0400718A RID: 29066
		private RaycastHit emptyHit;

		// Token: 0x0400718B RID: 29067
		private int bufferCount;

		// Token: 0x0400718C RID: 29068
		private Vector3 lastOpenHeadPosition;

		// Token: 0x0400718D RID: 29069
		private List<Material> tempMaterialArray = new List<Material>(16);

		// Token: 0x0400718E RID: 29070
		private Vector3? antiDriftLastPosition;

		// Token: 0x0400718F RID: 29071
		private const float CameraFarClipDefault = 500f;

		// Token: 0x04007190 RID: 29072
		private const float CameraNearClipDefault = 0.01f;

		// Token: 0x04007191 RID: 29073
		private const float CameraNearClipTiny = 0.002f;

		// Token: 0x04007192 RID: 29074
		private Dictionary<GameObject, PhysicsMaterial> bodyTouchedSurfaces;

		// Token: 0x04007193 RID: 29075
		private bool primaryButtonPressed = true;

		// Token: 0x04007194 RID: 29076
		[Header("Swimming")]
		public PlayerSwimmingParameters swimmingParams;

		// Token: 0x04007195 RID: 29077
		public WaterParameters waterParams;

		// Token: 0x04007196 RID: 29078
		public List<GTPlayer.LiquidProperties> liquidPropertiesList = new List<GTPlayer.LiquidProperties>(16);

		// Token: 0x04007197 RID: 29079
		public bool debugDrawSwimming;

		// Token: 0x04007198 RID: 29080
		[Header("Slam/Hit effects")]
		public GameObject wizardStaffSlamEffects;

		// Token: 0x04007199 RID: 29081
		public GameObject geodeHitEffects;

		// Token: 0x0400719A RID: 29082
		[Header("Freeze Tag")]
		public float freezeTagHandSlidePercent = 0.88f;

		// Token: 0x0400719B RID: 29083
		public bool debugFreezeTag;

		// Token: 0x0400719C RID: 29084
		public float frozenBodyBuoyancyFactor = 1.5f;

		// Token: 0x0400719E RID: 29086
		[Space]
		private WaterVolume leftHandWaterVolume;

		// Token: 0x0400719F RID: 29087
		private WaterVolume rightHandWaterVolume;

		// Token: 0x040071A0 RID: 29088
		private WaterVolume.SurfaceQuery leftHandWaterSurface;

		// Token: 0x040071A1 RID: 29089
		private WaterVolume.SurfaceQuery rightHandWaterSurface;

		// Token: 0x040071A2 RID: 29090
		private Vector3 swimmingVelocity = Vector3.zero;

		// Token: 0x040071A3 RID: 29091
		private WaterVolume.SurfaceQuery waterSurfaceForHead;

		// Token: 0x040071A4 RID: 29092
		private bool bodyInWater;

		// Token: 0x040071A5 RID: 29093
		private bool headInWater;

		// Token: 0x040071A6 RID: 29094
		private bool audioSetToUnderwater;

		// Token: 0x040071A7 RID: 29095
		private float buoyancyExtension;

		// Token: 0x040071A8 RID: 29096
		private float lastWaterSurfaceJumpTimeLeft = -1f;

		// Token: 0x040071A9 RID: 29097
		private float lastWaterSurfaceJumpTimeRight = -1f;

		// Token: 0x040071AA RID: 29098
		private float waterSurfaceJumpCooldown = 0.1f;

		// Token: 0x040071AB RID: 29099
		private float leftHandNonDiveHapticsAmount;

		// Token: 0x040071AC RID: 29100
		private float rightHandNonDiveHapticsAmount;

		// Token: 0x040071AD RID: 29101
		private List<WaterVolume> headOverlappingWaterVolumes = new List<WaterVolume>(16);

		// Token: 0x040071AE RID: 29102
		private List<WaterVolume> bodyOverlappingWaterVolumes = new List<WaterVolume>(16);

		// Token: 0x040071AF RID: 29103
		private List<WaterCurrent> activeWaterCurrents = new List<WaterCurrent>(16);

		// Token: 0x040071B1 RID: 29105
		private Quaternion playerRotationOverride;

		// Token: 0x040071B2 RID: 29106
		private int playerRotationOverrideFrame = -1;

		// Token: 0x040071B3 RID: 29107
		private float playerRotationOverrideDecayRate = Mathf.Exp(1.5f);

		// Token: 0x040071B5 RID: 29109
		private ContactPoint[] bodyCollisionContacts = new ContactPoint[8];

		// Token: 0x040071B6 RID: 29110
		private int bodyCollisionContactsCount;

		// Token: 0x040071B7 RID: 29111
		private ContactPoint bodyGroundContact;

		// Token: 0x040071B8 RID: 29112
		private float bodyGroundContactTime;

		// Token: 0x040071B9 RID: 29113
		private const float movingSurfaceVelocityLimit = 40f;

		// Token: 0x040071BA RID: 29114
		private bool exitMovingSurface;

		// Token: 0x040071BB RID: 29115
		private float exitMovingSurfaceThreshold = 6f;

		// Token: 0x040071BC RID: 29116
		private bool isClimbableMoving;

		// Token: 0x040071BD RID: 29117
		private Quaternion lastClimbableRotation;

		// Token: 0x040071BE RID: 29118
		private int lastAttachedToMovingSurfaceFrame;

		// Token: 0x040071BF RID: 29119
		private const int MIN_FRAMES_OFF_SURFACE_TO_DETACH = 3;

		// Token: 0x040071C0 RID: 29120
		private bool isHandHoldMoving;

		// Token: 0x040071C1 RID: 29121
		private Quaternion lastHandHoldRotation;

		// Token: 0x040071C2 RID: 29122
		private Vector3 movingHandHoldReleaseVelocity;

		// Token: 0x040071C3 RID: 29123
		private GTPlayer.MovingSurfaceContactPoint lastMovingSurfaceContact;

		// Token: 0x040071C4 RID: 29124
		private int lastMovingSurfaceID = -1;

		// Token: 0x040071C5 RID: 29125
		private BuilderPiece lastMonkeBlock;

		// Token: 0x040071C6 RID: 29126
		private Quaternion lastMovingSurfaceRot;

		// Token: 0x040071C7 RID: 29127
		private RaycastHit lastMovingSurfaceHit;

		// Token: 0x040071C8 RID: 29128
		private Vector3 lastMovingSurfaceTouchLocal;

		// Token: 0x040071C9 RID: 29129
		private Vector3 lastMovingSurfaceTouchWorld;

		// Token: 0x040071CA RID: 29130
		private Vector3 movingSurfaceOffset;

		// Token: 0x040071CB RID: 29131
		private bool wasMovingSurfaceMonkeBlock;

		// Token: 0x040071CC RID: 29132
		private Vector3 lastMovingSurfaceVelocity;

		// Token: 0x040071CD RID: 29133
		private bool wasBodyOnGround;

		// Token: 0x040071CE RID: 29134
		private BasePlatform currentPlatform;

		// Token: 0x040071CF RID: 29135
		private BasePlatform lastPlatformTouched;

		// Token: 0x040071D0 RID: 29136
		private Vector3 lastFrameTouchPosLocal;

		// Token: 0x040071D1 RID: 29137
		private Vector3 lastFrameTouchPosWorld;

		// Token: 0x040071D2 RID: 29138
		private bool lastFrameHasValidTouchPos;

		// Token: 0x040071D3 RID: 29139
		private Vector3 refMovement = Vector3.zero;

		// Token: 0x040071D4 RID: 29140
		private Vector3 platformTouchOffset;

		// Token: 0x040071D5 RID: 29141
		private Vector3 debugLastRightHandPosition;

		// Token: 0x040071D6 RID: 29142
		private Vector3 debugPlatformDeltaPosition;

		// Token: 0x040071D7 RID: 29143
		public double tempFreezeRightHandEnableTime;

		// Token: 0x040071D8 RID: 29144
		public double tempFreezeLeftHandEnableTime;

		// Token: 0x040071D9 RID: 29145
		private const float climbingMaxThrowSpeed = 5.5f;

		// Token: 0x040071DA RID: 29146
		private const float climbHelperSmoothSnapSpeed = 12f;

		// Token: 0x040071DB RID: 29147
		[NonSerialized]
		public bool isClimbing;

		// Token: 0x040071DC RID: 29148
		private GorillaClimbable currentClimbable;

		// Token: 0x040071DD RID: 29149
		private GorillaHandClimber currentClimber;

		// Token: 0x040071DE RID: 29150
		private Vector3 climbHelperTargetPos = Vector3.zero;

		// Token: 0x040071DF RID: 29151
		private Transform climbHelper;

		// Token: 0x040071E0 RID: 29152
		private GorillaRopeSwing currentSwing;

		// Token: 0x040071E1 RID: 29153
		private GorillaZipline currentZipline;

		// Token: 0x040071E2 RID: 29154
		[SerializeField]
		private ConnectedControllerHandler controllerState;

		// Token: 0x040071E3 RID: 29155
		public int sizeLayerMask;

		// Token: 0x040071E4 RID: 29156
		public bool InReportMenu;

		// Token: 0x040071E5 RID: 29157
		private LayerChanger layerChanger;

		// Token: 0x040071E8 RID: 29160
		private bool hasCorrectedForTracking;

		// Token: 0x040071E9 RID: 29161
		private float halloweenLevitationStrength;

		// Token: 0x040071EA RID: 29162
		private float halloweenLevitationFullStrengthDuration;

		// Token: 0x040071EB RID: 29163
		private float halloweenLevitationTotalDuration = 1f;

		// Token: 0x040071EC RID: 29164
		private float halloweenLevitationBonusStrength;

		// Token: 0x040071ED RID: 29165
		private float halloweenLevitateBonusOffAtYSpeed;

		// Token: 0x040071EE RID: 29166
		private float halloweenLevitateBonusFullAtYSpeed = 1f;

		// Token: 0x040071EF RID: 29167
		private float lastTouchedGroundTimestamp;

		// Token: 0x040071F0 RID: 29168
		private bool teleportToTrain;

		// Token: 0x040071F1 RID: 29169
		public bool isAttachedToTrain;

		// Token: 0x040071F2 RID: 29170
		private bool stuckLeft;

		// Token: 0x040071F3 RID: 29171
		private bool stuckRight;

		// Token: 0x040071F4 RID: 29172
		private float lastScale;

		// Token: 0x040071F5 RID: 29173
		private Vector3 currentSlopDirection;

		// Token: 0x040071F6 RID: 29174
		private Vector3 lastSlopeDirection = Vector3.zero;

		// Token: 0x040071F7 RID: 29175
		private readonly Dictionary<Object, Action<GTPlayer>> gravityOverrides = new Dictionary<Object, Action<GTPlayer>>();

		// Token: 0x040071FA RID: 29178
		private int hoverAllowedCount;

		// Token: 0x040071FB RID: 29179
		[Header("Hoverboard")]
		[SerializeField]
		private float hoverIdealHeight = 0.5f;

		// Token: 0x040071FC RID: 29180
		[SerializeField]
		private float hoverCarveSidewaysSpeedLossFactor = 1f;

		// Token: 0x040071FD RID: 29181
		[SerializeField]
		private AnimationCurve hoverCarveAngleResponsiveness;

		// Token: 0x040071FE RID: 29182
		[SerializeField]
		private HoverboardVisual hoverboardVisual;

		// Token: 0x040071FF RID: 29183
		[SerializeField]
		private float sidewaysDrag = 0.1f;

		// Token: 0x04007200 RID: 29184
		[SerializeField]
		private float hoveringSlowSpeed = 0.1f;

		// Token: 0x04007201 RID: 29185
		[SerializeField]
		private float hoveringSlowStoppingFactor = 0.95f;

		// Token: 0x04007202 RID: 29186
		[SerializeField]
		private float hoverboardPaddleBoostMultiplier = 0.1f;

		// Token: 0x04007203 RID: 29187
		[SerializeField]
		private float hoverboardPaddleBoostMax = 10f;

		// Token: 0x04007204 RID: 29188
		[SerializeField]
		private float hoverboardBoostGracePeriod = 1f;

		// Token: 0x04007205 RID: 29189
		[SerializeField]
		private float hoverBodyHasCollisionsOutsideRadius = 0.5f;

		// Token: 0x04007206 RID: 29190
		[SerializeField]
		private float hoverBodyCollisionRadiusUpOffset = 0.2f;

		// Token: 0x04007207 RID: 29191
		[SerializeField]
		private float hoverGeneralUpwardForce = 8f;

		// Token: 0x04007208 RID: 29192
		[SerializeField]
		private float hoverTiltAdjustsForwardFactor = 0.2f;

		// Token: 0x04007209 RID: 29193
		[SerializeField]
		private float hoverMinGrindSpeed = 1f;

		// Token: 0x0400720A RID: 29194
		[SerializeField]
		private float hoverSlamJumpStrengthFactor = 25f;

		// Token: 0x0400720B RID: 29195
		[SerializeField]
		private float hoverMaxPaddleSpeed = 35f;

		// Token: 0x0400720C RID: 29196
		[SerializeField]
		private HoverboardAudio hoverboardAudio;

		// Token: 0x0400720D RID: 29197
		private bool hasHoverPoint;

		// Token: 0x0400720E RID: 29198
		private float boostEnabledUntilTimestamp;

		// Token: 0x0400720F RID: 29199
		private GTPlayer.HoverBoardCast[] hoverboardCasts = new GTPlayer.HoverBoardCast[]
		{
			new GTPlayer.HoverBoardCast
			{
				localOrigin = new Vector3(0f, 1f, 0.36f),
				localDirection = Vector3.down,
				distance = 1f,
				sphereRadius = 0.2f,
				intersectToVelocityCap = 0.1f
			},
			new GTPlayer.HoverBoardCast
			{
				localOrigin = new Vector3(0f, 0.05f, 0.36f),
				localDirection = Vector3.forward,
				distance = 0.25f,
				sphereRadius = 0.01f,
				intersectToVelocityCap = 0f,
				isSolid = true
			},
			new GTPlayer.HoverBoardCast
			{
				localOrigin = new Vector3(0f, 0.05f, -0.1f),
				localDirection = -Vector3.forward,
				distance = 0.24f,
				sphereRadius = 0.01f,
				intersectToVelocityCap = 0f,
				isSolid = true
			}
		};

		// Token: 0x04007210 RID: 29200
		private Vector3 hoverboardPlayerLocalPos;

		// Token: 0x04007211 RID: 29201
		private Quaternion hoverboardPlayerLocalRot;

		// Token: 0x04007212 RID: 29202
		private bool didHoverLastFrame;

		// Token: 0x04007213 RID: 29203
		private bool hasLeftHandTentacleMove;

		// Token: 0x04007214 RID: 29204
		private bool hasRightHandTentacleMove;

		// Token: 0x04007215 RID: 29205
		private Vector3 leftHandTentacleMove;

		// Token: 0x04007216 RID: 29206
		private Vector3 rightHandTentacleMove;

		// Token: 0x04007217 RID: 29207
		private GTPlayer.HandHoldState activeHandHold;

		// Token: 0x04007218 RID: 29208
		private GTPlayer.HandHoldState secondaryHandHold;

		// Token: 0x04007219 RID: 29209
		public PhysicsMaterial slipperyMaterial;

		// Token: 0x0400721A RID: 29210
		private bool wasHoldingHandhold;

		// Token: 0x0400721B RID: 29211
		private Vector3 secondLastPreHandholdVelocity;

		// Token: 0x0400721C RID: 29212
		private Vector3 lastPreHandholdVelocity;

		// Token: 0x0400721D RID: 29213
		[Header("Native Scale Adjustment")]
		[SerializeField]
		private AnimationCurve nativeScaleMagnitudeAdjustmentFactor;

		// Token: 0x02000F5D RID: 3933
		[Serializable]
		public struct HandState
		{
			// Token: 0x06006339 RID: 25401 RVA: 0x002475F8 File Offset: 0x002457F8
			public void Init(GTPlayer gtPlayer, bool isLeftHand, float maxArmLength)
			{
				this.gtPlayer = gtPlayer;
				this.isLeftHand = isLeftHand;
				this.maxArmLength = maxArmLength;
				this.lastPosition = this.controllerTransform.position;
				this.lastRotation = this.controllerTransform.rotation;
				if (this.handFollower != null)
				{
					this.handFollower.transform.position = this.lastPosition;
					this.handFollower.transform.rotation = this.lastRotation;
				}
				this.wasColliding = false;
				this.slipSetToMaxFrameIdx = -1;
			}

			// Token: 0x0600633A RID: 25402 RVA: 0x00247684 File Offset: 0x00245884
			public void OnTeleport()
			{
				this.wasColliding = false;
				this.isColliding = false;
				this.isSliding = false;
				this.wasSliding = false;
				this.handFollower.position = this.controllerTransform.position;
				this.handFollower.rotation = this.controllerTransform.rotation;
				this.lastPosition = this.handFollower.transform.position;
				this.lastRotation = this.handFollower.transform.rotation;
			}

			// Token: 0x0600633B RID: 25403 RVA: 0x0007D1EB File Offset: 0x0007B3EB
			public Vector3 GetLastPosition()
			{
				return this.lastPosition + this.gtPlayer.MovingSurfaceMovement();
			}

			// Token: 0x0600633C RID: 25404 RVA: 0x0007D203 File Offset: 0x0007B403
			public bool SlipOverriddenToMax()
			{
				return this.slipSetToMaxFrameIdx == Time.frameCount;
			}

			// Token: 0x0600633D RID: 25405 RVA: 0x00247708 File Offset: 0x00245908
			public void FirstIteration(ref Vector3 totalMove, ref int divisor, float paddleBoostFactor)
			{
				if (this.hasCustomBoost)
				{
					this.boostVectorThisFrame = this.gtPlayer.turnParent.transform.rotation * -this.velocityTracker.GetAverageVelocity(false, 0.15f, false) * this.customBoostFactor;
				}
				else
				{
					this.boostVectorThisFrame = (this.gtPlayer.enableHoverMode ? (this.gtPlayer.turnParent.transform.rotation * -this.velocityTracker.GetAverageVelocity(false, 0.15f, false) * paddleBoostFactor) : Vector3.zero);
				}
				Vector3 vector = this.GetCurrentHandPosition() + this.gtPlayer.movingSurfaceOffset;
				Vector3 vector2 = this.GetLastPosition();
				Vector3 a = vector - vector2;
				bool flag = this.gtPlayer.lastMovingSurfaceContact == GTPlayer.MovingSurfaceContactPoint.LEFT;
				if (!this.gtPlayer.didAJump && this.wasSliding && Vector3.Dot(this.gtPlayer.slideAverageNormal, Vector3.up) > 0f)
				{
					a += Vector3.Project(-this.gtPlayer.slideAverageNormal * this.gtPlayer.stickDepth * this.gtPlayer.scale, Vector3.down);
				}
				float num = this.gtPlayer.minimumRaycastDistance * this.gtPlayer.scale;
				if (this.gtPlayer.IsFrozen && GorillaGameManager.instance is GorillaFreezeTagManager)
				{
					num = (this.gtPlayer.minimumRaycastDistance + VRRig.LocalRig.iceCubeRight.transform.localScale.y / 2f) * this.gtPlayer.scale;
				}
				Vector3 vector3 = Vector3.zero;
				if (flag && !this.gtPlayer.exitMovingSurface)
				{
					vector3 = Vector3.Project(-this.gtPlayer.lastMovingSurfaceHit.normal * (this.gtPlayer.stickDepth * this.gtPlayer.scale), Vector3.down);
					if (this.gtPlayer.scale < 0.5f)
					{
						Vector3 normalized = this.gtPlayer.MovingSurfaceMovement().normalized;
						if (normalized != Vector3.zero)
						{
							float num2 = Vector3.Dot(Vector3.up, normalized);
							if ((double)num2 > 0.9 || (double)num2 < -0.9)
							{
								vector3 *= 6f;
								num *= 1.1f;
							}
						}
					}
				}
				Vector3 a2;
				RaycastHit lastHitInfoHand;
				Vector3 b;
				if (this.gtPlayer.IterativeCollisionSphereCast(vector2, num, a + vector3, this.boostVectorThisFrame, out a2, true, out this.slipPercentage, out lastHitInfoHand, this.SlipOverriddenToMax()) && !this.isHolding && !this.gtPlayer.InReportMenu)
				{
					if (this.wasColliding && this.slipPercentage <= this.gtPlayer.defaultSlideFactor && !this.boostVectorThisFrame.IsLongerThan(0f))
					{
						b = vector2 - vector;
					}
					else
					{
						b = a2 - vector;
					}
					this.isSliding = (this.slipPercentage > this.gtPlayer.iceThreshold);
					this.slideNormal = this.gtPlayer.tempHitInfo.normal;
					this.isColliding = true;
					this.materialTouchIndex = this.gtPlayer.currentMaterialIndex;
					this.surfaceOverride = this.gtPlayer.currentOverride;
					this.gtPlayer.lastHitInfoHand = lastHitInfoHand;
					this.lastHitInfo = lastHitInfoHand;
				}
				else
				{
					b = Vector3.zero;
					this.slipPercentage = 0f;
					this.isSliding = false;
					this.slideNormal = Vector3.up;
					this.isColliding = false;
					this.materialTouchIndex = 0;
					this.surfaceOverride = null;
				}
				bool flag2 = this.isLeftHand ? this.gtPlayer.controllerState.LeftValid : this.gtPlayer.controllerState.RightValid;
				this.isColliding = (this.isColliding && flag2);
				this.isSliding = (this.isSliding && flag2);
				if (this.isColliding)
				{
					this.gtPlayer.anyHandIsColliding = true;
					if (this.isSliding)
					{
						this.gtPlayer.anyHandIsSliding = true;
					}
					else
					{
						this.gtPlayer.anyHandIsSticking = true;
					}
				}
				if (this.isColliding || this.wasColliding)
				{
					if (!this.surfaceOverride || !this.surfaceOverride.disablePushBackEffect)
					{
						totalMove += b;
					}
					divisor++;
				}
			}

			// Token: 0x0600633E RID: 25406 RVA: 0x00247B8C File Offset: 0x00245D8C
			public void FinalizeHandPosition()
			{
				Vector3 vector = this.GetLastPosition();
				if (Time.time < this.tempFreezeUntilTimestamp)
				{
					this.finalPositionThisFrame = vector;
				}
				else
				{
					Vector3 movementVector = this.GetCurrentHandPosition() - vector;
					float sphereRadius = this.gtPlayer.minimumRaycastDistance * this.gtPlayer.scale;
					if (this.gtPlayer.IsFrozen && GorillaGameManager.instance is GorillaFreezeTagManager)
					{
						sphereRadius = (this.gtPlayer.minimumRaycastDistance + VRRig.LocalRig.iceCubeRight.transform.localScale.y / 2f) * this.gtPlayer.scale;
					}
					Vector3 vector2;
					float num;
					RaycastHit lastHitInfoHand;
					if (this.gtPlayer.IterativeCollisionSphereCast(vector, sphereRadius, movementVector, this.boostVectorThisFrame, out vector2, this.gtPlayer.areBothTouching, out num, out lastHitInfoHand, false) && !this.isHolding)
					{
						this.isColliding = true;
						this.isSliding = (num > this.gtPlayer.iceThreshold);
						this.materialTouchIndex = this.gtPlayer.currentMaterialIndex;
						this.surfaceOverride = this.gtPlayer.currentOverride;
						this.gtPlayer.lastHitInfoHand = lastHitInfoHand;
						this.lastHitInfo = lastHitInfoHand;
						this.finalPositionThisFrame = vector2;
					}
					else
					{
						this.finalPositionThisFrame = this.GetCurrentHandPosition();
					}
				}
				bool flag = this.isLeftHand ? this.gtPlayer.controllerState.LeftValid : this.gtPlayer.controllerState.RightValid;
				this.isColliding = (this.isColliding && flag);
				this.isSliding = (this.isSliding && flag);
				if (this.isColliding)
				{
					this.gtPlayer.anyHandIsColliding = true;
					if (this.isSliding)
					{
						this.gtPlayer.anyHandIsSliding = true;
						return;
					}
					this.gtPlayer.anyHandIsSticking = true;
				}
			}

			// Token: 0x0600633F RID: 25407 RVA: 0x0007D203 File Offset: 0x0007B403
			public bool IsSlipOverriddenToMax()
			{
				return this.slipSetToMaxFrameIdx == Time.frameCount;
			}

			// Token: 0x06006340 RID: 25408 RVA: 0x00247D44 File Offset: 0x00245F44
			public Vector3 GetCurrentHandPosition()
			{
				Vector3 position = this.gtPlayer.headCollider.transform.position;
				if (this.gtPlayer.inOverlay)
				{
					return position + this.gtPlayer.headCollider.transform.up * -0.5f * this.gtPlayer.scale;
				}
				Vector3 vector = this.gtPlayer.PositionWithOffset(this.controllerTransform, this.handOffset);
				if ((vector - position).IsShorterThan(this.maxArmLength * this.gtPlayer.scale))
				{
					return vector;
				}
				return position + (vector - position).normalized * this.maxArmLength * this.gtPlayer.scale;
			}

			// Token: 0x06006341 RID: 25409 RVA: 0x0007D212 File Offset: 0x0007B412
			public void PositionHandFollower()
			{
				this.handFollower.position = this.finalPositionThisFrame;
				this.handFollower.rotation = this.lastRotation;
			}

			// Token: 0x06006342 RID: 25410 RVA: 0x00247E14 File Offset: 0x00246014
			public void OnEndOfFrame()
			{
				this.wasColliding = this.isColliding;
				this.wasSliding = this.isSliding;
				this.lastPosition = this.finalPositionThisFrame;
				if (Time.time > this.tempFreezeUntilTimestamp)
				{
					this.lastRotation = this.controllerTransform.rotation * this.handRotOffset;
				}
			}

			// Token: 0x06006343 RID: 25411 RVA: 0x0007D236 File Offset: 0x0007B436
			public void TempFreezeHand(float freezeDuration)
			{
				this.tempFreezeUntilTimestamp = Math.Max(this.tempFreezeUntilTimestamp, Time.time + freezeDuration);
			}

			// Token: 0x06006344 RID: 25412 RVA: 0x00247E70 File Offset: 0x00246070
			public void GetHandTapData(out bool wasHandTouching, out bool wasSliding, out int handMatIndex, out GorillaSurfaceOverride surfaceOverride, out RaycastHit handHitInfo, out Vector3 handPosition, out GorillaVelocityTracker handVelocityTracker)
			{
				wasHandTouching = this.wasColliding;
				wasSliding = this.wasSliding;
				handMatIndex = this.materialTouchIndex;
				surfaceOverride = this.surfaceOverride;
				handHitInfo = this.lastHitInfo;
				handPosition = this.finalPositionThisFrame;
				handVelocityTracker = this.velocityTracker;
			}

			// Token: 0x0400721E RID: 29214
			[NonSerialized]
			public Vector3 lastPosition;

			// Token: 0x0400721F RID: 29215
			[NonSerialized]
			public Quaternion lastRotation;

			// Token: 0x04007220 RID: 29216
			[NonSerialized]
			public bool isLeftHand;

			// Token: 0x04007221 RID: 29217
			[NonSerialized]
			public bool wasColliding;

			// Token: 0x04007222 RID: 29218
			[NonSerialized]
			public bool isColliding;

			// Token: 0x04007223 RID: 29219
			[NonSerialized]
			public bool wasSliding;

			// Token: 0x04007224 RID: 29220
			[NonSerialized]
			public bool isSliding;

			// Token: 0x04007225 RID: 29221
			[NonSerialized]
			public bool isHolding;

			// Token: 0x04007226 RID: 29222
			[NonSerialized]
			public Vector3 slideNormal;

			// Token: 0x04007227 RID: 29223
			[NonSerialized]
			public float slipPercentage;

			// Token: 0x04007228 RID: 29224
			[NonSerialized]
			public Vector3 hitPoint;

			// Token: 0x04007229 RID: 29225
			[NonSerialized]
			private Vector3 boostVectorThisFrame;

			// Token: 0x0400722A RID: 29226
			[NonSerialized]
			public Vector3 finalPositionThisFrame;

			// Token: 0x0400722B RID: 29227
			[NonSerialized]
			public int slipSetToMaxFrameIdx;

			// Token: 0x0400722C RID: 29228
			[NonSerialized]
			public int materialTouchIndex;

			// Token: 0x0400722D RID: 29229
			[NonSerialized]
			public GorillaSurfaceOverride surfaceOverride;

			// Token: 0x0400722E RID: 29230
			[NonSerialized]
			public RaycastHit hitInfo;

			// Token: 0x0400722F RID: 29231
			[NonSerialized]
			public RaycastHit lastHitInfo;

			// Token: 0x04007230 RID: 29232
			[NonSerialized]
			private GTPlayer gtPlayer;

			// Token: 0x04007231 RID: 29233
			[SerializeField]
			public Transform handFollower;

			// Token: 0x04007232 RID: 29234
			[SerializeField]
			public Transform controllerTransform;

			// Token: 0x04007233 RID: 29235
			[SerializeField]
			public GorillaVelocityTracker velocityTracker;

			// Token: 0x04007234 RID: 29236
			[SerializeField]
			public GorillaVelocityTracker interactPointVelocityTracker;

			// Token: 0x04007235 RID: 29237
			[SerializeField]
			public Vector3 handOffset;

			// Token: 0x04007236 RID: 29238
			[SerializeField]
			public Quaternion handRotOffset;

			// Token: 0x04007237 RID: 29239
			[NonSerialized]
			public float tempFreezeUntilTimestamp;

			// Token: 0x04007238 RID: 29240
			[NonSerialized]
			public bool canTag;

			// Token: 0x04007239 RID: 29241
			[NonSerialized]
			public bool canStun;

			// Token: 0x0400723A RID: 29242
			private float maxArmLength;

			// Token: 0x0400723B RID: 29243
			[NonSerialized]
			public bool isActive;

			// Token: 0x0400723C RID: 29244
			[NonSerialized]
			public float customBoostFactor;

			// Token: 0x0400723D RID: 29245
			[NonSerialized]
			public bool hasCustomBoost;
		}

		// Token: 0x02000F5E RID: 3934
		private enum MovingSurfaceContactPoint
		{
			// Token: 0x0400723F RID: 29247
			NONE,
			// Token: 0x04007240 RID: 29248
			RIGHT,
			// Token: 0x04007241 RID: 29249
			LEFT,
			// Token: 0x04007242 RID: 29250
			BODY
		}

		// Token: 0x02000F5F RID: 3935
		[Serializable]
		public struct MaterialData
		{
			// Token: 0x04007243 RID: 29251
			public string matName;

			// Token: 0x04007244 RID: 29252
			public bool overrideAudio;

			// Token: 0x04007245 RID: 29253
			public AudioClip audio;

			// Token: 0x04007246 RID: 29254
			public bool overrideSlidePercent;

			// Token: 0x04007247 RID: 29255
			public float slidePercent;

			// Token: 0x04007248 RID: 29256
			public int surfaceEffectIndex;
		}

		// Token: 0x02000F60 RID: 3936
		[Serializable]
		public struct LiquidProperties
		{
			// Token: 0x04007249 RID: 29257
			[Range(0f, 2f)]
			[Tooltip("0: no resistance just like air, 1: full resistance like solid geometry")]
			public float resistance;

			// Token: 0x0400724A RID: 29258
			[Range(0f, 3f)]
			[Tooltip("0: no buoyancy. 1: Fully compensates gravity. 2: net force is upwards equal to gravity")]
			public float buoyancy;

			// Token: 0x0400724B RID: 29259
			[Range(0f, 3f)]
			[Tooltip("Damping Half-life Multiplier")]
			public float dampingFactor;

			// Token: 0x0400724C RID: 29260
			[Range(0f, 1f)]
			public float surfaceJumpFactor;
		}

		// Token: 0x02000F61 RID: 3937
		public enum LiquidType
		{
			// Token: 0x0400724E RID: 29262
			Water,
			// Token: 0x0400724F RID: 29263
			Lava
		}

		// Token: 0x02000F62 RID: 3938
		private struct HoverBoardCast
		{
			// Token: 0x04007250 RID: 29264
			public Vector3 localOrigin;

			// Token: 0x04007251 RID: 29265
			public Vector3 localDirection;

			// Token: 0x04007252 RID: 29266
			public float sphereRadius;

			// Token: 0x04007253 RID: 29267
			public float distance;

			// Token: 0x04007254 RID: 29268
			public float intersectToVelocityCap;

			// Token: 0x04007255 RID: 29269
			public bool isSolid;

			// Token: 0x04007256 RID: 29270
			public bool didHit;

			// Token: 0x04007257 RID: 29271
			public Vector3 pointHit;

			// Token: 0x04007258 RID: 29272
			public Vector3 normalHit;
		}

		// Token: 0x02000F63 RID: 3939
		private struct HandHoldState
		{
			// Token: 0x04007259 RID: 29273
			public GorillaGrabber grabber;

			// Token: 0x0400725A RID: 29274
			public Transform objectHeld;

			// Token: 0x0400725B RID: 29275
			public Vector3 localPositionHeld;

			// Token: 0x0400725C RID: 29276
			public float localRotationalOffset;

			// Token: 0x0400725D RID: 29277
			public bool applyRotation;
		}
	}
}



Playspace:

using System;
using UnityEngine;

namespace GorillaLocomotion
{
	// Token: 0x02000F65 RID: 3941
	public sealed class Playspace : MonoBehaviour
	{
		// Token: 0x06006347 RID: 25415 RVA: 0x0007D25E File Offset: 0x0007B45E
		private void Awake()
		{
			this._sqrSphereRadius = this._sphereRadius * this._sphereRadius;
			this._sqrSnapToThreshold = this._snapToThreshold * this._snapToThreshold;
		}

		// Token: 0x06006348 RID: 25416 RVA: 0x00247FAC File Offset: 0x002461AC
		private void Update()
		{
			Vector3 b = this._localGorillaHead.transform.position - base.transform.position;
			float sqrMagnitude = b.sqrMagnitude;
			if (GTPlayer.Instance.enableHoverMode || GTPlayer.Instance.isClimbing || b.sqrMagnitude > this._sqrSnapToThreshold)
			{
				base.transform.position = this._localGorillaHead.transform.position;
				return;
			}
			Vector3 normalized = b.normalized;
			b = this.GetChaseSpeed() * Time.deltaTime * normalized;
			base.transform.position = ((b.sqrMagnitude > sqrMagnitude) ? this._localGorillaHead.transform.position : (base.transform.position + b));
			if ((this._localGorillaHead.transform.position - base.transform.position).sqrMagnitude > this._sqrSphereRadius)
			{
				this._localGorillaHead.transform.position = base.transform.position + this._sphereRadius * normalized;
			}
		}

		// Token: 0x06006349 RID: 25417 RVA: 0x0007D286 File Offset: 0x0007B486
		private float GetChaseSpeed()
		{
			return this._defaultChaseSpeed;
		}

		// Token: 0x0600634A RID: 25418 RVA: 0x0007D28E File Offset: 0x0007B48E
		private void OnDrawGizmosSelected()
		{
			Gizmos.DrawWireSphere(base.transform.position, this._sphereRadius);
		}

		// Token: 0x0600634B RID: 25419 RVA: 0x0003DFA4 File Offset: 0x0003C1A4
		public Playspace()
		{
		}

		// Token: 0x04007263 RID: 29283
		[SerializeField]
		private GameObject _localGorillaHead;

		// Token: 0x04007264 RID: 29284
		[SerializeField]
		private float _sphereRadius;

		// Token: 0x04007265 RID: 29285
		private float _sqrSphereRadius;

		// Token: 0x04007266 RID: 29286
		[SerializeField]
		private float _defaultChaseSpeed;

		// Token: 0x04007267 RID: 29287
		[SerializeField]
		private float _snapToThreshold;

		// Token: 0x04007268 RID: 29288
		private float _sqrSnapToThreshold;
	}
}
